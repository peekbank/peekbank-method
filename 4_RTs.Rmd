---
title: "RT Computation"
author: "Mike Frank"
date: "2022-12-15"
output: 
  html_document:
    toc: true
---

# RT options

In addition to accuracy, LWL time course data can also be turned into reaction times (RT) which seem to represent a different construct. 

Generally RT are only measured when a child shifts from the distractor to the target in response to the auditory stimulus. 

There are different options for how exactly to calculate this:

* what time point to use: one can either do "landing based rt" where the rt is to the first time the child looks at the target, or "launch based rt" when the child leaves the distractor. Launch based usually measures to the first time the child leaves the distractor.

* one could exclude cases where children take a long time between when their eyes leave the distractor (for the first or last time) and when the land on the target 

* as always, one can analyse RT either in ms or in log(ms) 

since it takes time for children to process the stimulus, the earliest stimulus-driven shift is not happening at t0 but some few hundred milliseconds later -- leading to some choices about what criteria to use to make sure that the child is on the distractor during the time when they are processing the stiumulus. We refer to this period as the "window". 
typically, children are required to be one the distractor the entire time between t_0 and the window end. however, depending on the state of missing data or imputation (and blinks and handling of tracker loss), it's possible this is too strict. 

here, we always require that children not look at the target during the window, and then consider the effects of 
* requiring children to be on the distractor at time_0
* requiring children to be on the distractor at the end of the window
* requiring children to be on the distractor a given fraction of the time between t_0 and t_end
* using different window lengths 

```{r, echo=F, include=F}
knitr::opts_chunk$set(warning=F, message=F, echo=F)
source(here::here("helper/common.R"))
```

(no need to run)
```{r, eval=F}
d_aoi <- readRDS(here("cached_intermediates", "1_d_aoi.Rds"))

source("helper/rt_helper.R")
```


```{r, eval=F}
rle_data <- d_aoi %>%
  filter(
    any(t_norm == 0), # must have data at 0
    t_norm >= 0
  ) %>% # only pass data after 0
  group_by(administration_id, trial_id, trial_order, dataset_name) %>%
  reframe(
    lengths = rle(aoi)$lengths,
    values = rle(aoi)$values
  )

grid_options <- expand_grid(
  window = c(200, 250, 300, 350, 375, 400, 425, 450, 500, 600, 700, 800, 900, 1000),
  time_0 = c(F, T), time_end = c(F, T), during = T, frac = c(0, .5, .75)
) |>
  bind_rows(expand_grid(
    window = c(0),
    time_0 = c(F, T), time_end = c(F), during = T, frac = c(0)
  )) |>
  bind_rows(expand_grid(
    window = c(200, 250, 300, 350, 375, 400, 425, 450, 500, 600, 700, 800, 900, 1000),
    time_0 = c(T), time_end = c(T), during = T, frac = c(1)
  ))

rts <- rle_data %>%
  group_by(administration_id, trial_id, trial_order) %>%
  nest() |>
  cross_join(grid_options) |>
  mutate(rts = pmap(
    list(data, time_0, window, time_end, during, frac),
    \(d, t0, w, te, dur, fr){
      print(window)
      get_rt(d,
        t_0 = t0, window_length = w,
        t_end = te, window_mostly_region = dur, mostly_fraction = fr
      )
    }
  )) |>
  select(-data) |>
  unnest(cols = c(rts)) |>
  left_join(d_aoi %>%
    select(administration_id, dataset_name, subject_id, trial_id, trial_order, target_label) %>%
    distinct())

saveRDS(rts, here("cached_intermediates", "4_rts.rds"))
```

```{r, eval=F}
library(multidplyr)

cluster <- new_cluster(8)
cluster_library(cluster, "dplyr")
cluster_library(cluster, "stringr")
cluster_library(cluster, "purrr")
cluster_library(cluster, "tidyr")
cluster_library(cluster, "agreement")
cluster_copy(cluster, "get_icc")

rts <- readRDS(here("cached_intermediates", "4_rts.rds"))

d_rt_dt <- rts |>
  filter(shift_type == "D-T") |>
  mutate(
    land_rt = rt,
    first_launch_rt = shift_start_rt,
    # last_launch_rt = last_shift_rt
  ) |>
  mutate(
    across(c("land_rt", "first_launch_rt"), log, .names = "log_{.col}"),
    across(
      c(
        "land_rt", "first_launch_rt",
        "log_land_rt", "log_first_launch_rt",
      ),
      ~ ifelse(shift_length <= 600, .x, NA),
      .names = "trim_first_{.col}"
    ),
    across(
      c(
        "land_rt", # "last_launch_rt",
        "log_land_rt", # "log_last_launch_rt"
      ),
      ~ ifelse(last_shift_length <= 600, .x, NA),
      .names = "trim_last_{.col}"
    )
  ) |>
  select(-rt, -shift_start_rt, -last_shift_rt) |>
  group_by(dataset_name, time_0, window, time_end, during, frac, administration_id, target_label) |>
  mutate(repetition = row_number())


rt_iccs <- d_rt_dt |>
  group_by(dataset_name, time_0, window, time_end, during, frac) |>
  nest() |>
  partition(cluster) |>
  mutate(icc_admin = map(data, \(d) {
    rt_names <- colnames(d)[str_ends(colnames(d), "rt")]
    n_total <- map_dbl(rt_names, \(rt_col) {
      d |>
        filter(!is.na(d[rt_col])) |>
        nrow()
    })
    n_admin <- map_dbl(rt_names, \(rt_col) {
      d |>
        filter(!is.na(d[rt_col])) |>
        select(administration_id) |>
        unique() |>
        nrow()
    })
    icc_values <- map_dbl(rt_names, \(rt_col) {
      get_icc(d |> filter(!is.na(d[rt_col])), column = rt_col, object = "administration")
    })
    tibble(measure = rt_names, icc = icc_values, n_total = n_total, n_admin = n_admin)
  })) |>
  collect() |>
  select(-data) |>
  unnest(icc_admin)

saveRDS(rt_iccs, here("cached_intermediates", "rt_iccs.rds"))
```

# how often do these choices matter?

given that there are different possible ways of calculating RT and different levels of strictness for inclusion, it is first useful to look at how often these choices could be relevant. 

```{r}
d_rt <- readRDS(here("cached_intermediates", "4_rts.rds")) |> filter(window == 0, time_0 == T)
```
 
 here we're looking at D-T transitions, where the child was on D at time 0
 
how much does launch versus landing based rt matter? 

```{r}
ggplot(d_rt, aes(x = shift_start_rt, y = rt)) +
  geom_point(alpha = .1) +
  geom_smooth(method = "lm")

ggplot(
  d_rt,
  aes(x = shift_start_rt, y = rt)
) +
  geom_point(alpha = .1) +
  geom_point(
    data = filter(d_rt, shift_length > 600),
    col = "red"
  ) +
  geom_smooth(method = "lm")
```
they are generally quite correlated, especially so if one removes shifts of >600ms. 

```{r}
# does type of start initiation matter

d_rt |>
  ungroup() |>
  filter(!is.na(shift_start_rt)) |>
  mutate(
    initiation_type_matters = shift_start_rt != last_shift_rt,
    long_shift_occurs = shift_length > 600
  ) |>
  group_by(initiation_type_matters, long_shift_occurs) |>
  tally() |>
  ungroup() |>
  mutate(pct = n / sum(n))
```
for the most part, these combos won't matter because >95% of the data has the kid only leaving once and doesn't have a long shift. 

distribution of shift lengths -- cut off at 1000ms; by far most shifts are <250ms where we count from first leaving distractor or last leaving distractor

```{r}
d_rt |> ggplot(aes(x = shift_length)) +
  geom_histogram(binwidth = 50) +
  coord_cartesian(xlim = c(0, 1000))
d_rt |> ggplot(aes(x = last_shift_length)) +
  geom_histogram(binwidth = 50) +
  coord_cartesian(xlim = c(0, 1000))
```
how much of the time are kids looking at the same thing between 0 and 400 ms -- many studies require looks to distractor + no shifts for 250/300/367 ms; how much data loss is coming from this?

```{r}
d_aoi <- readRDS(here("cached_intermediates", "1_d_aoi.Rds"))

t_0 <- d_aoi |>
  filter(t_norm == 0) |>
  mutate(t_0_aoi = aoi) |>
  select(administration_id, trial_id, dataset_name, t_0_aoi) |>
  mutate(t_0_aoi = ifelse(t_0_aoi %in% c("target", "distractor"), t_0_aoi, "other"))
t_375 <- d_aoi |>
  filter(t_norm == 375) |>
  mutate(t_375_aoi = aoi) |>
  select(administration_id, trial_id, dataset_name, t_375_aoi) |>
  mutate(t_375_aoi = ifelse(t_375_aoi %in% c("target", "distractor"), t_375_aoi, "other"))
early_dist <- d_aoi |>
  filter(t_norm < 400 & t_norm >= 0) |>
  group_by(administration_id, trial_id, dataset_name, aoi) |>
  tally() |>
  left_join(t_0) |>
  left_join(t_375) |>
  pivot_wider(names_from = aoi, values_from = n, values_fill = 0) |>
  mutate(type = case_when(
    target + distractor + missing + other != 16 ~ "some missing ts",
    target == 16 ~ "only target",
    distractor == 16 ~ "only distractor",
    missing + other == 16 ~ "all off",
    target == 0 & distractor > 8 ~ "d+m (mostly d)",
    target == 0 ~ "d+m (mostly m)",
    distractor == 0 & target > 8 ~ "t+m (mostly t)",
    distractor == 0 ~ "t+m (mostly m)",
    T ~ "both"
  )) |> filter(!is.na(t_0_aoi))

ggplot(early_dist, aes(x = t_0_aoi, fill = type)) +
  facet_wrap(~t_375_aoi) +
  geom_bar()

early_dist |>
  group_by(type, t_0_aoi, t_375_aoi) |>
  tally() |>
  ungroup() |>
  mutate(pct = round(n / sum(n), 3)) |>
  arrange(desc(pct))
```
we want to know of the ones that are on t/d/m at start

~33% is on distractor for 0-375
~32% is on target for 0-375

~10% is missing/other for 0-375(this is going to get tossed in all cases!)

~5.5% goes from d to t
~5.5% goes from t to d 

~5.5% is mostly on d during the time, with some being on other (at start/end/middle)
~4.5% is mostly on t during the time, with some being on other (at start/end/middle)

to look at:
* when we have d/other or t/other what's the typical patterns
  * how much is other & when
* for both t/d this probably can't be salvaged but look at patterns

```{r}
early_dist |>
  filter(target == 0) |>
  filter(missing + other < 16) |>
  filter(distractor != 16) |>
  ggplot(aes(x = distractor)) +
  geom_bar()

early_dist |>
  filter(distractor == 0) |>
  filter(missing + other < 16) |>
  filter(target != 16) |>
  ggplot(aes(x = target)) +
  geom_bar()
```
so, most of the d/m or t/m mixes is heavily weighted to d or t with only a little m.
when does this m occur?
```{r}
d_aoi |>
  filter(t_norm < 400 & t_norm >= 0) |>
  inner_join(early_dist |> filter(target == 0) |> filter(missing + other < 16) |> filter(distractor != 16) |> select(administration_id, dataset_name, trial_id, num_distractor = distractor)) |>
  mutate(is_distractor = ifelse(aoi == "distractor", 1, 0)) |>
  group_by(t_norm, num_distractor) |>
  summarize(is_distractor = mean(is_distractor)) |>
  ggplot(aes(x = t_norm, y = is_distractor, col = num_distractor, group = num_distractor)) +
  geom_point() +
  geom_line() +
  scale_color_viridis()
```
so, most of the d/m that is mostly d has the m at the beginning or end (rather than in the middle) -- possibly this is just because of how fixations work? 
this is especially true when d is >11 or so, which is most of this chunk of data. 

```{r}
d_aoi |>
  filter(t_norm < 400 & t_norm >= 0) |>
  inner_join(early_dist |> filter(distractor == 0) |> filter(missing + other < 16) |> filter(target != 16) |> select(administration_id, dataset_name, trial_id, num_target = target)) |>
  mutate(is_target = ifelse(aoi == "target", 1, 0)) |>
  group_by(t_norm, num_target) |>
  summarize(is_target = mean(is_target)) |>
  ggplot(aes(x = t_norm, y = is_target, col = num_target, group = num_target)) +
  geom_point() +
  geom_line() +
  scale_color_viridis()
```
## summary
Take-aways from data-viz:

* most of the data is reasonably behaved 30% T-T, 30% D-D, we're looking at whether we can save another like 5%ish onto either by relaxing early missing data requirements

* for other exclusions around long-shift, again, not much data is being affected (maybe 5% but some of this is also going to overlap more with data that has other issues)

# ICC of many options

We consider a few different options for how to get RTs
All of these are framed as D-T but same would apply for T-D

* we consider RTs measured either from the first time you leave D (first_launch) or the first time you arrive at T (land) [theoretically, the last time you leave D is another option, that was tried in an earlier iteration, but dropped here for tractability -- see descriptives above for this only mattering in a limited number of cases]

* raw v log RT
* the option to trim overly long shifts to 600ms either calculated from first leaving or final leaving

how do we determine that the kid is sufficiently on D at the relevant time:
* "relevant time" = window length in ms where they have to be not on T and potentially meet other constraints (below)
* time_0 -- do they have to be on D or just *not* on T
* window_end -- at the end of the window, do they have to be on D or just *not* on T
* fraction -- the minimum fraction of the time during the window that they have to be on D

```{r}
# identify datasets/combos with too little data to be reliable!

# we require 10 trials and 5 kids 
rt_dist <- readRDS(here("cached_intermediates", "4_rts.rds")) |> filter(shift_type=="D-T") |> 
  group_by(time_0, time_end, during, frac, dataset_name, window) |> summarize(trials=n(), admins=administration_id |> unique() |> length()) 
  
icc_cutoff <- rt_dist |> filter(trials>9, admins>4) |> select(dataset_name, time_0, time_end, during, frac, window)

#ggplot(rts, aes(x=trials, y=admins, color=dataset_name))+geom_point()
```

```{r}
rt_iccs <- readRDS(here("cached_intermediates", "4_rt_iccs.rds")) |> inner_join(icc_cutoff)

rt_iccs$dataset_name <- fct_reorder(rt_iccs$dataset_name, rt_iccs$icc)

rt_iccs_coded <- rt_iccs |> mutate(
  type = case_when(
    str_detect(measure, "first_launch_rt") ~ "first_launch",
    str_detect(measure, "last_launch_rt") ~ "last_launch",
    str_detect(measure, "land_rt") ~ "land"
  ),
  logged = case_when(
    str_detect(measure, "log") ~ "log",
    T ~ "raw"
  ),
  trimming = case_when(
    str_detect(measure, "trim_first") ~ "trim_first",
    str_detect(measure, "trim_last") ~ "trim_last",
    T ~ "untrimmed"
  )
)

rt_iccs_summ <- rt_iccs_coded |>
  group_by(type, logged, trimming, window, time_0, time_end, during, frac) |>
  summarize(mean_icc = mean(icc, na.rm = T), datapoints = sum(n_total))

```

there are a lot of combinations to look at!

we start by looking at the effect of (log/raw RT) x (launch v land) x (type of trimming of long shift lengths)

```{r}
rt_iccs_summ |> ggplot(aes(x = str_c(logged, "_", type), y = mean_icc, group = interaction(type, logged, trimming))) +
  geom_point(aes(col = trimming), position = position_dodge(width = .4)) +
  stat_summary(position = position_dodge(width = .4)) +
  coord_flip() +
  geom_hline(yintercept = .65) +
  scale_color_brewer(type = "qual", palette = 1)
```
The best options for each have pretty high ICC; this graph seems to suggest that landing is better than launch. 

what windows are good? 

```{r}
rt_iccs_summ |>
  ggplot(aes(x = window, y = mean_icc)) +
  geom_point(aes(col = window), position = position_dodge(width = .4)) +
  stat_summary(position = position_dodge(width = .4)) +
  coord_flip() +
  geom_hline(yintercept = .65) +
  scale_color_viridis()
```
we tried a lot of different window options, some of which we thought were likely to be bad, but here we can see that the "good" options are in the 250-500 range, so we'll focus there. 


```{r}
rt_iccs_summ |>
  filter(window >= 250, window <= 500) |>
  ggplot(aes(x = str_c("window_end", time_end), y = mean_icc, group = interaction(time_0, time_end, window))) +
  geom_point(aes(col = window), position = position_dodge(width = .4)) +
  stat_summary(position = position_dodge(width = .4)) +
  coord_flip() +
  facet_wrap(~ str_c("time_0", time_0)) +
  geom_hline(yintercept = .65) +
  scale_color_viridis()
```
generally having both window start and end be true is best (I think?).

looking specifically at 400 for window (which seems to be often best), what about fraction?

```{r}
rt_iccs_summ |>
  filter(window %in% c(400)) |>
  ggplot(aes(x = str_c("window_end", time_end), y = mean_icc, group = interaction(time_0, time_end, frac))) +
  geom_point(aes(col = as.character(frac)), position = position_dodge(width = .4)) +
  stat_summary(position = position_dodge(width = .4)) +
  coord_flip() +
  facet_wrap(~ str_c("time_0", time_0)) +
  geom_hline(yintercept = .65)
```
looking within the 400 window, looks like both start and end being true is important, but not the type of during. 

in the 200-600 ms window range, when the kid is on at time_0 and time_end, does it matter if they're on all the time in the middle and what time is best? 

```{r}
rt_iccs_summ |>
  filter(time_0, time_end, frac %in% c(0, 1)) |>
  filter(window >= 200, window <= 600) |>
  ggplot(aes(x = window, y = mean_icc, group = interaction(time_0, time_end, window))) +
  geom_point(aes(col = window), position = position_dodge(width = .4)) +
  stat_summary(position = position_dodge(width = .4)) +
  geom_hline(yintercept = .65) +
  facet_wrap(~frac) +
  scale_color_viridis()
```

so somewhere in the 375 to 500 looks best, probably doesn't matter whether you're on the whole time as long as you're on start and end. 

looking at this 375-500 subset, and returning to the land versus launch effects. 

```{r}
rt_iccs_summ |>
  filter(time_0, time_end, frac %in% c(0, 1)) |>
  filter(window >= 375, window <= 500) |>
  ggplot(aes(x = str_c(logged, "_", type), y = mean_icc, group = interaction(type, logged, trimming))) +
  geom_point(aes(col = trimming), position = position_dodge(width = .4)) +
  stat_summary(position = position_dodge(width = .4)) +
  coord_flip() +
  geom_hline(yintercept = .65) +
  scale_color_brewer(type = "qual", palette = 1)
```
looking again, at 400, land + untrimmed seems fine!


```{r}
rt_iccs_summ |>
  filter(time_0, time_end) |>
  filter(frac %in% c(0, 1)) |>
  filter(window >= 375, window <= 500) |>
  filter(type == "land") |>
  filter(trimming == "untrimmed") |>
  ggplot(aes(x = window, y = mean_icc, group = interaction(time_0, time_end, window))) +
  geom_point(aes(col = window), position = position_dodge(width = .4)) +
  geom_hline(yintercept = .65) +
  scale_color_viridis()
```
so, best options seem to be 
time_0 = T
time_end = T
window = sometime in 375-500
land
untrimmed is fine 
don't bother about fraction

# ICC bootstrapping

From the above, we now take the more salient options and try to figure out how much they matter. 

We consider windows in the 200-500 range, we consider log or raw, and we consider 3 approaches to cleaning and calculating RT:

* traditional launch: RT is when the child first leaves the distractor; if it takes over 600 ms between when they first leave the distractor and when they land on the target, that's excluded; and the child must be continuously on the distractor for the entirety of the window

* traditional land: RT is when the child first looks to the target, and the and the child must be continuously on the distractor for the entirety of the window

* generous: (so called for excluding less data); a landing baesd RT, where as long as the child is looking at the distractor at the start and end of the window, and not looking at the target during the window, it's included. 

```{r, eval=F}
library(multidplyr)

cluster <- new_cluster(16)
cluster_library(cluster, "dplyr")
cluster_library(cluster, "stringr")
cluster_library(cluster, "purrr")
cluster_library(cluster, "tidyr")
cluster_library(cluster, "agreement")
cluster_copy(cluster, "bootstrap_icc")

rts <- readRDS("rts.rds")

d_rt_dt <- rts |>
  filter(window %in% c(200, 350, 375, 400, 425, 450, 500)) |>
  filter(frac %in% c(0, 1)) |>
  filter(time_0 == T, time_end == T) |>
  filter(shift_type == "D-T") |>
  mutate(
    land_rt = rt,
    first_launch_rt = shift_start_rt,
    # last_launch_rt = last_shift_rt
  ) |>
  mutate(
    across(c("land_rt", "first_launch_rt"), log, .names = "log_{.col}"),
    across(
      c(
        "land_rt", "first_launch_rt",
        "log_land_rt", "log_first_launch_rt",
      ),
      ~ ifelse(shift_length <= 600, .x, NA),
      .names = "trim_first_{.col}"
    ),
  ) |>
  select(-rt, -shift_start_rt, -last_shift_rt) |>
  group_by(dataset_name, time_0, window, time_end, during, frac, administration_id, target_label) |>
  mutate(repetition = row_number())


rt_iccs <- d_rt_dt |>
  group_by(dataset_name, time_0, window, time_end, during, frac) |>
  nest() |>
  partition(cluster) |>
  mutate(icc_admin = map(data, \(d) {
    rt_names <- colnames(d)[str_ends(colnames(d), "rt")]
    n_total <- map_dbl(rt_names, \(rt_col) {
      d |>
        filter(!is.na(d[rt_col])) |>
        nrow()
    })
    n_admin <- map_dbl(rt_names, \(rt_col) {
      d |>
        filter(!is.na(d[rt_col])) |>
        select(administration_id) |>
        unique() |>
        nrow()
    })
    icc_values <- map(rt_names, \(rt_col) {
      bootstrap_icc(d |> filter(!is.na(d[rt_col])), column = rt_col, bootstrap = 2000)
    })
    tibble(
      measure = rt_names, foo = icc_values,
      n_total = n_total, n_admin = n_admin
    )
    # icc_values
  })) |>
  collect() |>
  select(-data) |>
  unnest(icc_admin) |>
  unnest(foo)

saveRDS(rt_iccs, here("cached_intermediates", "4_rt_iccs_boot.rds"))
```

```{r}
rt_boot <- readRDS(here("cached_intermediates", "4_rt_iccs_boot.rds")) |> inner_join(icc_cutoff) |> 
    mutate(
    type = case_when(
      str_detect(measure, "first_launch_rt") ~ "first_launch",
      str_detect(measure, "last_launch_rt") ~ "last_launch",
      str_detect(measure, "land_rt") ~ "land"
    ),
    logged = case_when(
      str_detect(measure, "log") ~ "log",
      T ~ "raw"
    ),
    trimming = case_when(
      str_detect(measure, "trim_first") ~ "trim_first",
      str_detect(measure, "trim_last") ~ "trim_last",
      T ~ "untrimmed"
    )
  ) |>
  mutate(approach = case_when(
    type == "land" & trimming == "untrimmed" & frac == "0" ~ "generous",
    type == "land" & trimming == "untrimmed" & frac == "1" ~ "trad_land",
    type == "first_launch" & trimming == "trim_first" & frac == "1" ~ "trad_launch"
  )) |>
  filter(!is.na(approach)) |> 
  group_by(dataset_name) |> 
  mutate(options_count=n()) |> 
  filter(dataset_name!="ferguson_eyetrackingr") |> 
  select(-options_count) |> ungroup()

library(metafor)
rt_boot_summ <- rt_boot |>
  filter(!is.na(lower), !is.na(upper)) |>
  mutate(
    stdev = (upper - lower) / (1.96 * 2),
    var = stdev**2
  ) |>
  group_by(window, during, logged, approach) |>
  nest() |>
  mutate(icc = map(data, \(d){
    rma(d$est, d$var) |>
      summary() |>
      coef()
  })) |>
  select(-data) |>
  unnest(icc)
```


here we look at the overall CIs across datasets. 

```{r}
rt_boot_summ |> ggplot(aes(x = approach, color = as.character(window), y = estimate, ymin = ci.lb, ymax = ci.ub)) +
  geom_pointrange(position = position_dodge(width = .5)) +
  coord_flip() +
  geom_hline(yintercept=.7)+
  facet_wrap(~logged) +
  scale_color_viridis(discrete = T)
```
200 does not seem like a good window, but the details in the ~400ms zone don't seem to matter. Both log and raw are reasonable, and all three approaches are reasonable. 

faceting the other way

```{r}
rt_boot_summ |> ggplot(aes(x = approach, color = approach, y = estimate, ymin = ci.lb, ymax = ci.ub)) +
  geom_pointrange() +
    geom_hline(yintercept=.7)+
  coord_flip() +
  facet_grid(window ~ logged)
```
landing based approaches seem a little better than launch-based. 

We can look at each dataset individually at 400ms. 
```{r}
rt_boot |>
  filter(window == 400, logged == "raw") |>
  ggplot(aes(x = approach, color = approach, y = est, ymin = lower, ymax = upper)) +
  geom_pointrange() +
    geom_hline(yintercept=.7)+
  coord_flip() +
  facet_wrap(~dataset_name)

rt_boot |>
  filter(window == 400, logged == "log") |>
  ggplot(aes(x = approach, color = approach, y = est, ymin = lower, ymax = upper)) +
  geom_pointrange() +
    geom_hline(yintercept=.7)+
  coord_flip() +
  facet_wrap(~dataset_name)
```

## age split half 

```{r, eval=F}
source("cl_helper.R")
library(multidplyr)

cluster <- new_cluster(16)
cluster_library(cluster, "dplyr")
cluster_library(cluster, "stringr")
cluster_library(cluster, "purrr")
cluster_library(cluster, "tidyr")
cluster_library(cluster, "agreement")
cluster_copy(cluster, "bootstrap_icc")

rts <- readRDS("rts.rds")
d_aoi <- readRDS("d_aoi.Rds")
d_rt_dt <- rts |>
  left_join(d_aoi |> select(age, administration_id) |> distinct()) |>
  filter(window %in% c(200, 350, 375, 400, 425, 450, 500)) |>
  filter(frac %in% c(0, 1)) |>
  filter(time_0 == T, time_end == T) |>
  filter(shift_type == "D-T") |>
  mutate(
    land_rt = rt,
    first_launch_rt = shift_start_rt,
    # last_launch_rt = last_shift_rt
  ) |>
  mutate(
    across(c("land_rt", "first_launch_rt"), log, .names = "log_{.col}"),
    across(
      c(
        "land_rt", "first_launch_rt",
        "log_land_rt", "log_first_launch_rt",
      ),
      ~ ifelse(shift_length <= 600, .x, NA),
      .names = "trim_first_{.col}"
    ),
  ) |>
  select(-rt, -shift_start_rt, -last_shift_rt) |>
  mutate(younger = age < 24) |>
  group_by(dataset_name, time_0, window, time_end, during, frac, administration_id, target_label, younger) |>
  mutate(repetition = row_number())


rt_iccs_age <- d_rt_dt |>
  group_by(dataset_name, younger, time_0, window, time_end, during, frac) |>
  nest() |>
  partition(cluster) |>
  mutate(icc_admin = map(data, \(d) {
    rt_names <- colnames(d)[str_ends(colnames(d), "rt")]
    n_total <- map_dbl(rt_names, \(rt_col) {
      d |>
        filter(!is.na(d[rt_col])) |>
        nrow()
    })
    n_admin <- map_dbl(rt_names, \(rt_col) {
      d |>
        filter(!is.na(d[rt_col])) |>
        select(administration_id) |>
        unique() |>
        nrow()
    })
    icc_values <- map(rt_names, \(rt_col) {
      bootstrap_icc(d |> filter(!is.na(d[rt_col])), column = rt_col, bootstrap = 2000)
    })
    tibble(
      measure = rt_names, foo = icc_values,
      n_total = n_total, n_admin = n_admin
    )
    # icc_values
  })) |>
  collect() |>
  select(-data) |>
  unnest(icc_admin) |>
  unnest(foo)

saveRDS(rt_iccs_age, here("cached_intermediates", "4_rt_iccs_age_boot.rds"))

```


```{r}
rt_dist <- readRDS(here("cached_intermediates", "4_rts.rds")) |> filter(shift_type=="D-T") |> 
    left_join(d_aoi |> select(age, administration_id) |> distinct()) |>
    mutate(younger = age < 24) |>
  group_by(time_0, time_end, during, frac, dataset_name, window, younger) |> summarize(trials=n(), admins=administration_id |> unique() |> length()) 

age_cutoff <- rt_dist |> filter(trials>9, admins>4) |> select(dataset_name, younger)


rt_age_boot <- readRDS(here("cached_intermediates", "4_rt_iccs_age_boot.rds")) |>
  inner_join(age_cutoff) |> 
  mutate(
    type = case_when(
      str_detect(measure, "first_launch_rt") ~ "first_launch",
      str_detect(measure, "last_launch_rt") ~ "last_launch",
      str_detect(measure, "land_rt") ~ "land"
    ),
    logged = case_when(
      str_detect(measure, "log") ~ "log",
      T ~ "raw"
    ),
    trimming = case_when(
      str_detect(measure, "trim_first") ~ "trim_first",
      str_detect(measure, "trim_last") ~ "trim_last",
      T ~ "untrimmed"
    )
  ) |>
  mutate(approach = case_when(
    type == "land" & trimming == "untrimmed" & frac == "0" ~ "generous",
    type == "land" & trimming == "untrimmed" & frac == "1" ~ "trad_land",
    type == "first_launch" & trimming == "trim_first" & frac == "1" ~ "trad_launch"
  )) |>
  filter(!is.na(approach)) |> 
  mutate(younger=ifelse(younger, "<24months", ">=24months")) |> 
  group_by(younger, dataset_name) |> mutate(counts=n()) |> 
  filter(counts==42) |> select(-counts)

library(metafor)
rt_age_boot_summ <- rt_age_boot |>
  filter(!is.na(lower), !is.na(upper)) |>
  mutate(
    stdev = (upper - lower) / (1.96 * 2),
    var = stdev**2
  ) |>
  group_by(window, during, logged, approach, younger) |>
  nest() |>
  mutate(icc = map(data, \(d){
    rma(d$est, d$var, control=list(stepadj=0.5)) |>
      summary() |>
      coef()
  })) |>
  select(-data) |>
  unnest(icc)
```


```{r}
rt_age_boot_summ |> ggplot(aes(x = approach, color = as.character(window), y = estimate, ymin = ci.lb, ymax = ci.ub)) +
  geom_pointrange(position = position_dodge(width = .5)) +
  coord_flip() +
  facet_grid(younger~logged) +
  scale_color_viridis(discrete = T)
```


```{r}
rt_age_boot_summ |> ggplot(aes(x = str_c(approach,"_", logged), color = approach, y = estimate, ymin = ci.lb, ymax = ci.ub)) +
  geom_pointrange() +
  coord_flip() +
  facet_grid(window ~ younger)
```

note that we seem to also be getting biased estimates here, sigh. It should be fine, since it's being variance weighted and such. 

```{r}
rt_age_boot |>
  filter(window == 400, logged == "raw") |>
  ggplot(aes(x = approach, color = younger, y = est, ymin = lower, ymax = upper)) +
  geom_pointrange() +
  coord_flip() +
  facet_wrap(~dataset_name)
```


```{r}
rt_age_boot |>
  filter(window == 400, logged == "log") |>
  ggplot(aes(x = approach, color = younger, y = est, ymin = lower, ymax = upper)) +
  geom_pointrange() +
  coord_flip() +
  facet_wrap(~dataset_name)
```
It looks like from ICC, none of the approaches being used are bad, but landing based methods seem to be a bit more reliable, and the best window is around 400ms, which seems substantially more reliable than 200ms. 

# Validity via CDI 

We don't necessarily think that RT is measuring the same thing as the CDI, but we do expect the measures to correlate. Note that *faster* RT will go with higher CDI scores, so we expect a *negative* correlation here. 

```{r, eval=F}
source("cl_helper.R")

d_aoi <- readRDS("d_aoi.Rds")

cdi_data <- readRDS("cdi.rds")

do_cdi <- function(data, indices) {
  summ <- data |>
    slice(indices) |>
    left_join(cdi_data) |>
    ungroup() |>
    summarise(
      cor_comp = ifelse(sum(!is.na(comp) & !is.na(mean_var)) > 2, cor.test(mean_var, comp)$estimate, as.numeric(NA)),
      cor_prod = ifelse(sum(!is.na(prod) & !is.na(mean_var)) > 2, cor.test(mean_var, prod)$estimate, as.numeric(NA)),
      cor_age = ifelse(sum(!is.na(age) & !is.na(mean_var)) > 2, cor.test(mean_var, age)$estimate, as.numeric(NA))
    )
  cors <- c(summ$cor_comp[1], summ$cor_prod[1], summ$cor_age[1])
  names(cors) <- c("cor_comp", "cor_prod", "cor_age")

  return(cors)
}

boot_cdi <- function(data) {
  data |>
    group_by(dataset_name) |>
    nest() |>
    mutate(corr = map(data, \(d) {
      b <- boot::boot(d, do_cdi, 2000)
      if (is.na(b$t0[1])) {
        comp_lower <- NA
        comp_upper <- NA
      } else {
        ci_comp <- boot::boot.ci(b, index = 1, type = "basic")
        comp_lower <- ci_comp$basic[4]
        comp_upper <- ci_comp$basic[5]
      }
      if (is.na(b$t0[2])) {
        prod_lower <- NA
        prod_upper <- NA
      } else {
        ci_prod <- boot::boot.ci(b, index = 2, type = "basic")
        prod_lower <- ci_prod$basic[4]
        prod_upper <- ci_prod$basic[5]
      }
      if (is.na(b$t0[3])) {
        age_lower <- NA
        age_upper <- NA
      } else {
        ci_age <- boot::boot.ci(b, index = 3, type = "basic")
        age_lower <- ci_age$basic[4]
        age_upper <- ci_age$basic[5]
      }
      tibble(
        comp_est = b$t0[1], comp_lower = comp_lower, comp_upper = comp_upper,
        prod_est = b$t0[2], prod_lower = prod_lower, prod_upper = prod_upper,
        age_est = b$t0[3], age_lower = age_lower, age_upper = age_upper,
      )
    })) |>
    select(-data) |>
    unnest(corr)
}


cluster <- new_cluster(16)
cluster_library(cluster, "dplyr")
cluster_library(cluster, "stringr")
cluster_library(cluster, "purrr")
cluster_library(cluster, "tidyr")
cluster_library(cluster, "stats")
cluster_library(cluster, "tibble")
cluster_copy(cluster, "do_cdi")
cluster_copy(cluster, "d_aoi")
cluster_copy(cluster, "cdi_data")
cluster_copy(cluster, "boot_cdi")
cluster_copy(cluster, "acc_cdi")
cluster_copy(cluster, "bc_acc_cdi")



rts <- readRDS("rts.rds")


d_rt_dt <- rts |>
  filter(window %in% c(200, 350, 375, 400, 425, 450, 500)) |>
  filter(frac %in% c(0, 1)) |>
  filter(time_0 == T, time_end == T) |>
  filter(shift_type == "D-T") |>
  mutate(
    land_rt = rt,
    first_launch_rt = shift_start_rt,
    # last_launch_rt = last_shift_rt
  ) |>
  mutate(
    across(c("land_rt", "first_launch_rt"), log, .names = "log_{.col}"),
    across(
      c(
        "first_launch_rt",
        "log_first_launch_rt",
      ),
      ~ ifelse(shift_length <= 600, .x, NA),
      .names = "trim_first_{.col}"
    ),
  ) |>
  select(-rt, -shift_start_rt, -last_shift_rt) |>
  group_by(dataset_name, time_0, window, time_end, during, frac, administration_id, target_label)

d_rt_dt_long <- d_rt_dt |>
  pivot_longer(ends_with("rt"), names_to = "measure", values_to = "rt") |>
  mutate(
    type = case_when(
      str_detect(measure, "first_launch_rt") ~ "first_launch",
      str_detect(measure, "last_launch_rt") ~ "last_launch",
      str_detect(measure, "land_rt") ~ "land"
    ),
    logged = case_when(
      str_detect(measure, "log") ~ "log",
      T ~ "raw"
    ),
    trimming = case_when(
      str_detect(measure, "trim_first") ~ "trim_first",
      T ~ "untrimmed"
    )
  ) |>
  mutate(approach = case_when(
    type == "land" & trimming == "untrimmed" & frac == "0" ~ "generous",
    type == "land" & trimming == "untrimmed" & frac == "1" ~ "trad_land",
    type == "first_launch" & trimming == "trim_first" & frac == "1" ~ "trad_launch"
  )) |>
  filter(!is.na(approach))


rt_cdi <- function(w, a, l) {
  d_rt_dt_long |>
    filter(window == w, approach == a, logged == l) |>
    group_by(dataset_name, administration_id) |>
    summarize(mean_var = mean(rt, na.rm = T)) |>
    boot_cdi()
}

cluster_copy(cluster, "rt_cdi")
cluster_copy(cluster, "d_rt_dt_long")

rt_params <- expand_grid(
  approach = c("generous", "trad_launch", "trad_land"),
  window = c(200, 350, 375, 400, 425, 450, 500),
  logged = c("log", "raw")
)


rt_bootstrap_cdi <- rt_params |>
  partition(cluster) |>
  mutate(cdi = pmap(list(window, approach, logged), \(w, a, l) {
    rt_cdi(w, a, l)
  })) |>
  collect() |>
  unnest(cdi)

saveRDS(rt_bootstrap_cdi, here("cached_intermediates", "4_rt_kid_cdi.rds"))

```

```{r, eval=F}
# how many trials!

cdi_data <- readRDS(here("cached_intermediates", "1_cdi_subjects.Rds"))

rt_dist <- readRDS(here("cached_intermediates", "4_rts.rds")) |> filter(shift_type=="D-T") |> 
  left_join(cdi_data)|> 
  group_by(time_0, time_end, during, frac, dataset_name, window)


```

```{r}
rt_kid_cdi <- readRDS(here("cached_intermediates", "4_rt_kid_cdi.rds")) |> filter(dataset_name!="ferguson_eyetrackingr")

library(metafor)

rt_kid_cdi_summ <-  rt_kid_cdi |>
  mutate(
    comp_stdev = (comp_upper - comp_lower) / (1.96 * 2),
    comp_var = comp_stdev**2,
    prod_stdev = (prod_upper - prod_lower) / (1.96 * 2),
    prod_var = prod_stdev**2,
    age_stdev = (age_upper - age_lower) / (1.96 * 2),
    age_var = age_stdev**2
  ) |>
  group_by(approach, window, logged) |>
  nest() |>
  mutate(comp= map(data, \(d){
    rma(d$comp_est, d$comp_var) |>
      summary() |>
      coef()
  }),
  prod= map(data, \(d){
    rma(d$prod_est, d$prod_var) |>
      summary() |>
      coef()
  }),
  age= map(data, \(d){
    rma(d$age_est, d$age_var) |>
      summary() |>
      coef()
  })) |>
  select(-data) |>
  unnest(c(comp, prod, age), names_sep="_")

```

Correlating with production
```{r}
rt_kid_cdi_summ |> ggplot(aes(x = str_c(approach, "_", logged), y = prod_estimate, ymin=prod_ci.lb, ymax=prod_ci.ub, color=as.character(window))) +geom_pointrange(position=position_dodge(width=.5))+
  scale_color_viridis(discrete=T)+
  coord_flip()
```

correlating with production on a per-dataset basis, for window=400

```{r}
rt_kid_cdi |>filter(window==400) |> filter(!is.na(prod_est)) |>  ggplot(aes(x = str_c(approach, "_", logged), y = prod_est, ymin=prod_lower, ymax=prod_upper,  col=approach)) +
  geom_pointrange() +
  coord_flip() +
  geom_hline(yintercept=0)+
  theme(legend.position = "none") +
  facet_wrap(~dataset_name)
```

all correlations are negative as expected!


correlating with comprehension
```{r}
rt_kid_cdi_summ |> ggplot(aes(x = str_c(approach, "_", logged), y = comp_estimate, ymin=comp_ci.lb, ymax=comp_ci.ub, color=as.character(window))) +geom_pointrange(position=position_dodge(width=.5))+
  scale_color_viridis(discrete=T)+
  coord_flip()
```

per-dataset basis, at window==400

```{r}
rt_kid_cdi |>filter(window==400) |> filter(!is.na(comp_est)) |>  ggplot(aes(x = str_c(approach, "_", logged), y = comp_est, ymin=comp_lower, ymax=comp_upper,  col=approach)) +
  geom_pointrange() +
  coord_flip() +
  geom_hline(yintercept=0)+
  theme(legend.position = "none") +
  facet_wrap(~dataset_name)
```
it's a little strange that estimates are positive for baumgartner and fernald_marchman_2012. I guess the baumgartner kids are really young and so have small vocabs? Not sure what's up with fm2012. 

We can check on correlation with age as well, just to confirm. 

```{r}
rt_kid_cdi_summ |> ggplot(aes(x = str_c(approach, "_", logged), y = age_estimate, ymin=age_ci.lb, ymax=age_ci.ub, color=as.character(window))) +geom_pointrange(position=position_dodge(width=.5))+
  scale_color_viridis(discrete=T)+
  coord_flip()
```


```{r}
rt_kid_cdi |>filter(window==400) |> filter(!is.na(age_est)) |>  ggplot(aes(x = str_c(approach, "_", logged), y = age_est, ymin=age_lower, ymax=age_upper,  col=approach)) +
  geom_pointrange() +
  coord_flip() +
geom_hline(yintercept=0)+
  theme(legend.position = "none") +
  facet_wrap(~dataset_name)
```
age is a little bit all over the place (which we saw in accuracy as well), possibly because some datasets have narrow age ranges. 

Within the range of options we considered here, no real variation in validity levels. If we had to choose based on validity, a moderate time window end (~375?) and log is preferable. 

# Test-retest kid level

```{r, eval=F}
source("cl_helper.R")

d_aoi <- readRDS("d_aoi.Rds")
library(tibble)
library(multidplyr)

admins <- d_aoi |>
  select(dataset_name, subject_id, administration_id, age) |>
  distinct()
repeated <- admins |>
  group_by(dataset_name, subject_id) |>
  tally() |>
  filter(n > 1)

repeated_subjects <- admins |> inner_join(repeated)

pairs <- repeated_subjects |>
  group_by(dataset_name, subject_id) |>
  mutate(
    forward_age = lead(age),
    forward_diff = forward_age - age,
    test_num = case_when(
      forward_diff < 1.5 ~ 1,
    ),
    mean_age = case_when(
      test_num == 1 ~ (age + forward_age) / 2,
    ),
    second_admin = case_when(
      test_num == 1 ~ lead(administration_id)
    )
  ) |>
  filter(!is.na(test_num)) |>
  rename(first_admin = administration_id) |>
  select(-n, -age) |>
  left_join(repeated_subjects |> select(-age, -n), by = c("dataset_name", "subject_id", "second_admin" = "administration_id")) |>
  ungroup() |>
  mutate(pair_number = row_number()) |>
  select(-forward_age, -forward_diff, -test_num)

pairs_long <- pairs |> pivot_longer(c("first_admin", "second_admin"), names_to = "session_num", values_to = "administration_id")

pairs_aoi_data <- pairs_long |> left_join(d_aoi)


test_retest_corr <- function(data, indices) {
  summ <- data |>
    slice(indices) |>
    summarise(cor_test_retest = ifelse(sum(!is.na(first_admin) & !is.na(second_admin)) > 2, cor.test(first_admin, second_admin)$estimate, NA))
  return(summ$cor_test_retest[1])
}

boot_test_retest <- function(data) {
  data |>
    select(-administration_id) |>
    pivot_wider(names_from = session_num, values_from = mean_var) |>
    group_by(dataset_name) |>
    nest() |>
    # head(1) |>
    mutate(corr = map(data, \(d) {
      b <- boot::boot(d, test_retest_corr, 2000)
      ci <- boot::boot.ci(b, type = "basic")
      print(ci)
      tibble(est = b$t0, lower = ci$basic[4], upper = ci$basic[5])
    })) |>
    select(-data) |>
    unnest(corr)
}


rt_data <- readRDS("rts.rds")

d_rt_dt <- rt_data |>
  filter(window %in% c(200, 350, 375, 400, 425, 450, 500)) |>
  filter(frac %in% c(0, 1)) |>
  filter(time_0 == T, time_end == T) |>
  filter(shift_type == "D-T") |>
  mutate(
    land_rt = rt,
    first_launch_rt = shift_start_rt,
    # last_launch_rt = last_shift_rt
  ) |>
  mutate(
    across(c("land_rt", "first_launch_rt"), log, .names = "log_{.col}"),
    across(
      c(
        "first_launch_rt",
        "log_first_launch_rt",
      ),
      ~ ifelse(shift_length <= 600, .x, NA),
      .names = "trim_first_{.col}"
    ),
  ) |>
  select(-rt, -shift_start_rt, -last_shift_rt) |>
  group_by(dataset_name, time_0, window, time_end, during, frac, administration_id, target_label)

d_rt_dt_long <- d_rt_dt |>
  pivot_longer(ends_with("rt"), names_to = "measure", values_to = "rt") |>
  mutate(
    type = case_when(
      str_detect(measure, "first_launch_rt") ~ "first_launch",
      str_detect(measure, "last_launch_rt") ~ "last_launch",
      str_detect(measure, "land_rt") ~ "land"
    ),
    logged = case_when(
      str_detect(measure, "log") ~ "log",
      T ~ "raw"
    ),
    trimming = case_when(
      str_detect(measure, "trim_first") ~ "trim_first",
      T ~ "untrimmed"
    )
  ) |>
  mutate(approach = case_when(
    type == "land" & trimming == "untrimmed" & frac == "0" ~ "generous",
    type == "land" & trimming == "untrimmed" & frac == "1" ~ "trad_land",
    type == "first_launch" & trimming == "trim_first" & frac == "1" ~ "trad_launch"
  )) |>
  filter(!is.na(approach))

rt_pairs <- pairs_long |>
  left_join(d_rt_dt_long |> ungroup() |> select(administration_id, rt, approach, window, logged, dataset_name) |>
    select(administration_id, rt, approach, window, logged, dataset_name))

rt_test_retest <- function(w, a, l) {
  rt_pairs |>
    filter(window == w, approach == a, logged == l) |>
    group_by(dataset_name, administration_id, subject_id, pair_number, session_num) |>
    summarize(mean_var = mean(rt, na.rm = T), .groups = "drop") |>
    boot_test_retest()
}

cluster_copy(cluster, "rt_test_retest")
cluster_copy(cluster, "rt_pairs")

rt_params <- expand_grid(
  approach = c("generous", "trad_launch", "trad_land"),
  window = c(200, 350, 375, 400, 425, 450, 500),
  logged = c("log", "raw")
)

rt_bootstrap_test_retest <- rt_params |>
  partition(cluster) |>
  mutate(cdi = pmap(list(window, approach, logged), \(w, a, l) {
    rt_test_retest(w, a, l)
  })) |>
  collect() |>
  unnest(cdi)

saveRDS(rt_bootstrap_test_retest, here("cached_intermediates", "4_rt_kid_test_retest.rds"))

```

```{r}
rt_kid_test_retest <- readRDS(here("cached_intermediates", "4_rt_kid_test_retest.rds")) 

library(metafor)
rt_kid_test_retest_summ <-  rt_kid_test_retest |>
  mutate(
    stdev = (upper - lower) / (1.96 * 2),
    var = stdev**2,
  ) |>
  group_by(approach, window, logged) |>
  nest() |>
  mutate(corr= map(data, \(d){
    rma(d$est, d$var) |>
      summary() |>
      coef()
  })) |> 
  unnest(corr)
```

Looking at test-retest, at a 400 ms window, we are getting some amount of reliability (varying by dataset), no big differences between approaches. 

```{r}
rt_kid_test_retest |> filter(window==400) |> ggplot(aes(x=str_c(approach, "_", logged), y=est, ymin=lower, ymax=upper, color=as.character(approach)))+geom_pointrange(position = position_dodge(width=.5))+facet_wrap(~dataset_name)+coord_flip()+geom_hline(yintercept=0)
```

let's look at window (across all datasets)

```{r}
rt_kid_test_retest_summ |> ggplot(aes(x=str_c(approach, "_", logged), y=estimate, ymin=ci.lb, ymax=ci.ub, color=as.character(window)))+geom_pointrange(position = position_dodge(width=.5))+coord_flip()+scale_color_viridis(discrete=T)

```
strangely, the shortest windows we're considering (200ms) have better test-retest (even though they have worse properties on other accounts)

let's check this dataset by dataset

looking at raw trad-launch
```{r}
rt_kid_test_retest |> filter(approach=="trad_launch", logged=="raw") |> ggplot(aes(x=window, y=est, ymin=lower, ymax=upper, color=as.character(window)))+geom_pointrange()+facet_wrap(~dataset_name)+coord_flip()+scale_color_viridis(discrete=T)+geom_hline(yintercept=0)
```
looking at raw trad land

```{r}
rt_kid_test_retest |> filter(approach=="trad_land", logged=="raw") |> ggplot(aes(x=window, y=est, ymin=lower, ymax=upper, color=as.character(window)))+geom_pointrange()+facet_wrap(~dataset_name)+coord_flip()+scale_color_viridis(discrete=T)+geom_hline(yintercept=0)
```
looking at generous


```{r}
rt_kid_test_retest |> filter(approach=="generous", logged=="raw") |> ggplot(aes(x=window, y=est, ymin=lower, ymax=upper, color=as.character(window)))+geom_pointrange()+facet_wrap(~dataset_name)+coord_flip()+scale_color_viridis(discrete=T)+geom_hline(yintercept=0)
```
still not huge differences, but what is favored for test-retest reliability might not be quite the same as what is favored for ICC

# Summary

I think our biggest takeaway is that it makes sense to do slightly longer windows more on the 375-400 ms than shorter windows like 200ms. 

Landing RT (with no exclusions for shift length) is slightly better in terms of ICC than launch based RT (with shift length exclusions), and they are pretty equivalent for CDI comparisons and test-retest. 

Depending on data pre-processing, if there's a little missing data in the 0-400ms window, it's probably okay to include (but this occurs rarely here). 

Overall, the range of common and reasonable choices lead to reasonable results. 

```{r, eval=F}
canonical_rt <- readRDS(here("cached_intermediates", "4_rts.rds"))  |>
  filter(window %in% c(400)) |>
  filter(frac %in% c(0, 1)) |>
  filter(time_0 == T, time_end == T) |>
  filter(shift_type == "D-T") |>
  mutate(
    land_rt = rt,
    first_launch_rt = shift_start_rt,
    # last_launch_rt = last_shift_rt
  ) |>
  mutate(
    across(c("land_rt", "first_launch_rt"), log, .names = "log_{.col}"),
    across(
      c(
        "first_launch_rt",
        "log_first_launch_rt",
      ),
      ~ ifelse(shift_length <= 600, .x, NA),
      .names = "trim_first_{.col}"
    ),
  ) |>
  select(-rt, -shift_start_rt, -last_shift_rt) |>
  group_by(dataset_name, time_0, window, time_end, during, frac, administration_id, target_label) |> 
  pivot_longer(ends_with("rt"), names_to = "measure", values_to = "rt") |>
  mutate(
    type = case_when(
      str_detect(measure, "first_launch_rt") ~ "first_launch",
      str_detect(measure, "last_launch_rt") ~ "last_launch",
      str_detect(measure, "land_rt") ~ "land"
    ),
    logged = case_when(
      str_detect(measure, "log") ~ "log",
      T ~ "raw"
    ),
    trimming = case_when(
      str_detect(measure, "trim_first") ~ "trim_first",
      T ~ "untrimmed"
    )
  ) |>
  mutate(approach = case_when(
    type == "land" & trimming == "untrimmed" & frac == "0" ~ "generous",
    type == "land" & trimming == "untrimmed" & frac == "1" ~ "trad_land",
    type == "first_launch" & trimming == "trim_first" & frac == "1" ~ "trad_launch"
  )) |>
  filter(!is.na(approach)) |> 
  left_join(d_aoi%>%
    select(administration_id, dataset_name, subject_id, trial_id, trial_order, target_label) %>%
    distinct())

saveRDS(canonical_rt, here("cached_intermediates", "4_rt_canonical.rds"))
```



<!--
```{r, eval=F}
load(file = "cached_intermediates/3_accs.Rds")

accs_best <- accs |>
  filter(t_start == 400, t_end == 4000) |>
  filter(object == "administration") |>
  select(dataset_name, icc) |>
  mutate(type = "acc")

rts_best <- readRDS(here("cached_intermediates", "4_rt_iccs_log.rds")) |>
  filter(frac == 0, measure == "land_rt") |>
  ungroup() |>
  select(dataset_name, icc) |>
  mutate(type = "rt")

accs_best |>
  bind_rows(rts_best) |>
  ggplot(aes(x = dataset_name, y = icc, col = type)) +
  geom_point() +
  coord_flip()

accs_best |>
  bind_rows(rts_best) |>
  ggplot(aes(x = type, y = icc, col = type)) +
  geom_point() +
  stat_summary() +
  coord_flip()
```
RT tends to have higher reliability than accuracy (whether that is *meaningful* reliability is another matter) 




CDI trial level (deprecated)

set up CDI bootstrapping

```{r, eval=F}
do_cdi_rt <- function(data, indices) {
  summ <- data |>
    slice(indices) |>
    group_by(administration_id) |>
    summarize(rt = mean(rt, na.rm = T)) |>
    left_join(cdi_data) |>
    ungroup() |>
    summarise(
      cor_comp = ifelse(sum(!is.na(comp) & !is.na(rt)) > 2, cor.test(rt, comp)$estimate, as.numeric(NA)),
      cor_prod = ifelse(sum(!is.na(prod) & !is.na(rt)) > 2, cor.test(rt, prod)$estimate, as.numeric(NA)),
      cor_age = ifelse(sum(!is.na(age) & !is.na(rt)) > 2, cor.test(rt, age)$estimate, as.numeric(NA))
    )
  cors <- c(summ$cor_comp[1], summ$cor_prod[1], summ$cor_age[1])
  names(cors) <- c("cor_comp", "cor_prod", "cor_age")

  return(cors)
}



cluster <- new_cluster(16)
cluster_library(cluster, "dplyr")
cluster_library(cluster, "stringr")
cluster_library(cluster, "purrr")
cluster_library(cluster, "tidyr")
cluster_library(cluster, "stats")
cluster_library(cluster, "tibble")
# cluster_library(cluster, "agreement")
# cluster_copy(cluster, "bootstrap_icc")
cluster_copy(cluster, "do_cdi_rt")
cluster_copy(cluster, "cdi_data")

rts <- readRDS("rts.rds")


d_rt_dt <- rts |>
  filter(window %in% c(200, 350, 375, 400, 425, 450, 500)) |>
  filter(frac %in% c(0, 1)) |>
  filter(time_0 == T, time_end == T) |>
  filter(shift_type == "D-T") |>
  mutate(
    land_rt = rt,
    first_launch_rt = shift_start_rt,
    # last_launch_rt = last_shift_rt
  ) |>
  mutate(
    across(c("land_rt", "first_launch_rt"), log, .names = "log_{.col}"),
    across(
      c(
        "first_launch_rt",
        "log_first_launch_rt",
      ),
      ~ ifelse(shift_length <= 600, .x, NA),
      .names = "trim_first_{.col}"
    ),
  ) |>
  select(-rt, -shift_start_rt, -last_shift_rt) |>
  group_by(dataset_name, time_0, window, time_end, during, frac, administration_id, target_label)

d_rt_dt_long <- d_rt_dt |>
  pivot_longer(ends_with("rt"), names_to = "measure", values_to = "rt") |>
  mutate(
    type = case_when(
      str_detect(measure, "first_launch_rt") ~ "first_launch",
      str_detect(measure, "last_launch_rt") ~ "last_launch",
      str_detect(measure, "land_rt") ~ "land"
    ),
    logged = case_when(
      str_detect(measure, "log") ~ "log",
      T ~ "raw"
    ),
    trimming = case_when(
      str_detect(measure, "trim_first") ~ "trim_first",
      T ~ "untrimmed"
    )
  ) |>
  mutate(approach = case_when(
    type == "land" & trimming == "untrimmed" & frac == "0" ~ "generous",
    type == "land" & trimming == "untrimmed" & frac == "1" ~ "trad_land",
    type == "first_launch" & trimming == "trim_first" & frac == "1" ~ "trad_launch"
  )) |>
  filter(!is.na(approach))

bootstrap_cdi <- d_rt_dt_long |>
  ungroup() |>
  select(administration_id, rt, approach, window, logged, dataset_name) |>
  group_by(approach, window, logged, dataset_name) |>
  nest() |>
  partition(cluster) |>
  mutate(corr = map(data, \(d) {
    b <- boot::boot(d, do_cdi_rt, 2000)
    if (is.na(b$t0[1])) {
      comp_lower <- NA
      comp_upper <- NA
    } else {
      ci_comp <- boot::boot.ci(b, index = 1, type = "basic")
      comp_lower <- ci_comp$basic[4]
      comp_upper <- ci_comp$basic[5]
    }
    if (is.na(b$t0[2])) {
      prod_lower <- NA
      prod_upper <- NA
    } else {
      ci_prod <- boot::boot.ci(b, index = 2, type = "basic")
      prod_lower <- ci_prod$basic[4]
      prod_upper <- ci_prod$basic[5]
    }
    if (is.na(b$t0[3])) {
      age_lower <- NA
      age_upper <- NA
    } else {
      ci_age <- boot::boot.ci(b, index = 3, type = "basic")
      age_lower <- ci_age$basic[4]
      age_upper <- ci_age$basic[5]
    }
    tibble(
      comp_est = b$t0[1], comp_lower = comp_lower, comp_upper = comp_upper,
      prod_est = b$t0[2], prod_lower = prod_lower, prod_upper = prod_upper,
      age_est = b$t0[3], age_lower = age_lower, age_upper = age_upper,
    )
  })) |>
  collect() |>
  select(-data) |>
  unnest(corr)

saveRDS(bootstrap_cdi, "4_rt_cdi_boot.rds")

```

analyse

```{r, eval=F}
bootstrap_cdi <- readRDS(here("cached_intermediates", "4_rt_cdi_boot.rds"))

library(metafor)

bootstrap_cdi_summ <-  bootstrap_cdi |>
  mutate(
    comp_stdev = (comp_upper - comp_lower) / (1.96 * 2),
    comp_var = comp_stdev**2,
    prod_stdev = (prod_upper - prod_lower) / (1.96 * 2),
    prod_var = prod_stdev**2,
    age_stdev = (age_upper - age_lower) / (1.96 * 2),
    age_var = age_stdev**2
  ) |>
  group_by(approach, window, logged) |>
  nest() |>
  mutate(comp= map(data, \(d){
    rma(d$comp_est, d$comp_var) |>
      summary() |>
      coef()
  }),
  prod= map(data, \(d){
    rma(d$prod_est, d$prod_var) |>
      summary() |>
      coef()
  }),
  age= map(data, \(d){
    rma(d$age_est, d$age_var) |>
      summary() |>
      coef()
  })) |>
  select(-data) |>
  unnest(c(comp, prod, age), names_sep="_")

```
correlation with production: note that shorter RT are associated with more knowledge, so we expect negative correlations with production 

```{r, eval=F}
bootstrap_cdi_summ |> ggplot(aes(x = str_c(approach, "_", logged), y = prod_estimate, ymin=prod_ci.lb, ymax=prod_ci.ub, color=as.character(window))) +geom_pointrange(position=position_dodge(width=.5))+
  scale_color_viridis(discrete=T)+
  coord_flip()


bootstrap_cdi |>filter(window==400) |> filter(!is.na(prod_est)) |>  ggplot(aes(x = str_c(approach, "_", logged), y = prod_est, ymin=prod_lower, ymax=prod_upper,  col=approach)) +
  geom_pointrange() +
  coord_flip() +
  theme(legend.position = "none") +
  facet_wrap(~dataset_name)
```

some effect based on window, but it looks like (when we look at the per-dataset data), that it's mostly driven by ferguson which has only 155 trial total (28 admins, 6 target labels), and here we're getting between 6 and 18 trials, which is low (and a really low data-retention rate!)


correlation with comprehension
```{r, eval=F}
bootstrap_cdi_summ |> ggplot(aes(x = str_c(approach, "_", logged), y = comp_estimate, ymin=comp_ci.lb, ymax=comp_ci.ub, color=as.character(window))) +geom_pointrange(position=position_dodge(width=.5))+
  scale_color_viridis(discrete=T)+
  coord_flip()


bootstrap_cdi |>filter(window==400) |> filter(!is.na(comp_est)) |>  ggplot(aes(x = str_c(approach, "_", logged), y = comp_est, ymin=comp_lower, ymax=comp_upper,  col=approach)) +
  geom_pointrange() +
  coord_flip() +
  theme(legend.position = "none") +
  facet_wrap(~dataset_name)
```

correlation with age
```{r, eval=F}
bootstrap_cdi_summ |> ggplot(aes(x = str_c(approach, "_", logged), y = age_estimate, ymin=age_ci.lb, ymax=age_ci.ub, color=as.character(window))) +geom_pointrange(position=position_dodge(width=.5))+
  scale_color_viridis(discrete=T)+
  coord_flip()


bootstrap_cdi |>filter(window==400) |> filter(!is.na(age_est)) |>  ggplot(aes(x = str_c(approach, "_", logged), y = age_est, ymin=age_lower, ymax=age_upper,  col=approach)) +
  geom_pointrange() +
  coord_flip() +
  theme(legend.position = "none") +
  facet_wrap(~dataset_name)
```

Test-retest (trial level, deprecated)


```{r, eval=F}
source("cl_helper.R")

d_aoi <- readRDS("d_aoi.Rds")
library(tibble)
library(multidplyr)

cdi_data <- readRDS("cdi.rds")

admins <- d_aoi |>
  select(dataset_name, subject_id, administration_id, age) |>
  distinct()
repeated <- admins |>
  group_by(dataset_name, subject_id) |>
  tally() |>
  filter(n > 1)

repeated_subjects <- admins |> inner_join(repeated)
# identify pairs
# hmm, sometimes we have times with 3+ 1 month apart,
# for now allow all the pairs that result so like 14-15 and 15-16 for the same kid

pairs <- repeated_subjects |>
  group_by(dataset_name, subject_id) |>
  mutate(
    forward_age = lead(age),
    forward_diff = forward_age - age,
    test_num = case_when(
      forward_diff < 1.5 ~ 1,
    ),
    mean_age = case_when(
      test_num == 1 ~ (age + forward_age) / 2,
    ),
    second_admin = case_when(
      test_num == 1 ~ lead(administration_id)
    )
  ) |>
  filter(!is.na(test_num)) |>
  rename(first_admin = administration_id) |>
  select(-n, -age) |>
  left_join(repeated_subjects |> select(-age, -n), by = c("dataset_name", "subject_id", "second_admin" = "administration_id")) |>
  ungroup() |>
  mutate(pair_number = row_number()) |>
  select(-forward_age, -forward_diff, -test_num)

pairs_long <- pairs |> pivot_longer(c("first_admin", "second_admin"), names_to = "session_num", values_to = "administration_id")

rt_data <- readRDS("rts.rds")


d_rt_dt <- rt_data |>
  filter(window %in% c(200, 350, 375, 400, 425, 450, 500)) |>
  filter(frac %in% c(0, 1)) |>
  filter(time_0 == T, time_end == T) |>
  filter(shift_type == "D-T") |>
  mutate(
    land_rt = rt,
    first_launch_rt = shift_start_rt,
    # last_launch_rt = last_shift_rt
  ) |>
  mutate(
    across(c("land_rt", "first_launch_rt"), log, .names = "log_{.col}"),
    across(
      c(
        "first_launch_rt",
        "log_first_launch_rt",
      ),
      ~ ifelse(shift_length <= 600, .x, NA),
      .names = "trim_first_{.col}"
    ),
  ) |>
  select(-rt, -shift_start_rt, -last_shift_rt) |>
  group_by(dataset_name, time_0, window, time_end, during, frac, administration_id, target_label)

d_rt_dt_long <- d_rt_dt |>
  pivot_longer(ends_with("rt"), names_to = "measure", values_to = "rt") |>
  mutate(
    type = case_when(
      str_detect(measure, "first_launch_rt") ~ "first_launch",
      str_detect(measure, "last_launch_rt") ~ "last_launch",
      str_detect(measure, "land_rt") ~ "land"
    ),
    logged = case_when(
      str_detect(measure, "log") ~ "log",
      T ~ "raw"
    ),
    trimming = case_when(
      str_detect(measure, "trim_first") ~ "trim_first",
      T ~ "untrimmed"
    )
  ) |>
  mutate(approach = case_when(
    type == "land" & trimming == "untrimmed" & frac == "0" ~ "generous",
    type == "land" & trimming == "untrimmed" & frac == "1" ~ "trad_land",
    type == "first_launch" & trimming == "trim_first" & frac == "1" ~ "trad_launch"
  )) |>
  filter(!is.na(approach))


test_retest_boot <- function(data, indices) {
  summ <- data |>
    slice(indices) |>
    group_by(administration_id, subject_id, pair_number, session_num) |>
    summarize(mean_var = mean(rt, na.rm = T), .groups = "drop") |>
    select(-administration_id) |>
    pivot_wider(names_from = session_num, values_from = mean_var)

  cor_test_retest <- ifelse("first_admin" %in% names(summ) & "second_admin" %in% names(summ) &
    sum(!is.na(summ$first_admin) & !is.na(summ$second_admin)) > 2,
  cor.test(summ$first_admin, summ$second_admin)$estimate, NA
  )
  return(cor_test_retest[1])
}


library(multidplyr)
library(boot)
cluster <- new_cluster(16)
cluster_library(cluster, "dplyr")
cluster_library(cluster, "stringr")
cluster_library(cluster, "purrr")
cluster_library(cluster, "tidyr")
cluster_library(cluster, "stats")
cluster_library(cluster, "tibble")
cluster_library(cluster, "boot")
cluster_copy(cluster, "test_retest_boot")
cluster_copy(cluster, "cdi_data")

rt_boot_test_retest <- pairs_long |>
  left_join(d_rt_dt_long |> ungroup() |> select(administration_id, rt, approach, window, logged, dataset_name) |>
    select(administration_id, rt, approach, window, logged, dataset_name)) |>
  group_by(approach, window, logged, dataset_name) |>
  nest() |>
  partition(cluster) |>
  mutate(corr = map(data, \(d) {
    b <- boot::boot(d, test_retest_boot, 2000)
    t <- b[["t"]][, 1]
    t_no_na <- t[!is.na(t)]
    # print(t_no_na)
    t0 <- b[["t0"]][1][1]
    # print(t0)
    if (is.na(t0)) {
      return(tibble(est = NA, lower = NA, upper = NA))
    }
    if (length(t_no_na) == 0) {
      return(tibble(est = t0, lower = NA, upper = NA))
    }
    b$R <- length(t_no_na)
    ci <- boot::boot.ci(boot.out = b, t = t_no_na, t0 = t0, type = "basic")
    return(tibble(est = t0, lower = ci$basic[4], upper = ci$basic[5]))
  })) |>
  collect() |>
  select(-data) |>
  unnest(corr)

saveRDS(rt_boot_test_retest, here("cached_intermediates", "4_rt_boot_test_retest.rds"))

```

```{r, eval=F}
rt_boot_test_retest <- readRDS(here("cached_intermediates", "4_rt_boot_test_retest.rds")) |> filter(!is.na(approach)) #idk why there are nas here

library(metafor)
rt_boot_test_retest_summ <-  rt_boot_test_retest |>
  mutate(
    stdev = (upper - lower) / (1.96 * 2),
    var = stdev**2,
  ) |>
  group_by(approach, window, logged) |>
  nest() |>
  mutate(corr= map(data, \(d){
    rma(d$est, d$var) |>
      summary() |>
      coef()
  })) |> 
  unnest(corr)
  
rt_boot_test_retest |> filter(window==400) |> ggplot(aes(x=str_c(approach, "_", logged), y=est, ymin=lower, ymax=upper, color=as.character(approach)))+geom_pointrange(position = position_dodge(width=.5))+facet_wrap(~dataset_name)+coord_flip()

rt_boot_test_retest |> filter(approach=="trad_launch", logged=="raw") |> ggplot(aes(x=window, y=est, ymin=lower, ymax=upper, color=as.character(window)))+geom_pointrange()+facet_wrap(~dataset_name)+coord_flip()+scale_color_viridis(discrete=T)

rt_boot_test_retest_summ |> ggplot(aes(x=str_c(approach, "_", logged), y=estimate, ymin=ci.lb, ymax=ci.ub, color=as.character(window)))+geom_pointrange(position = position_dodge(width=.5))+coord_flip()+scale_color_viridis(discrete=T)

```

