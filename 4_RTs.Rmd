---
title: "RT Computation"
author: "Mike Frank"
date: "2022-12-15"
output: html_document
---


```{r}
source(here::here("helper/common.R"))
```
# Load data and prep intermediates

(no need to run)
```{r}
d_aoi <- readRDS(here("cached_intermediates", "1_d_aoi.Rds"))
```

```{r}
source("helper/rt_helper.R")
```


## Prep
looking at
* the 3 options for RT = the first time you leave, the last time you leave before landing, when you land
* raw v log RT
* the option to trim for max shift length of 600ms either calculated from first leaving or final leaving


```{r}
rle_data <- d_aoi %>%
  filter(
    any(t_norm == 0), # must have data at 0
    t_norm >= 0
  ) %>% # only pass data after 0
  group_by(administration_id, trial_id, trial_order, dataset_name) %>%
  reframe(
    lengths = rle(aoi)$lengths,
    values = rle(aoi)$values
  )

grid_options <- expand_grid(
  window = c(200, 250, 300, 350, 375, 400, 425, 450, 500, 600, 700, 800, 900, 1000),
  time_0 = c(F, T), time_end = c(F, T), during = T, frac = c(0, .5, .75)
) |>
  bind_rows(expand_grid(
    window = c(0),
    time_0 = c(F, T), time_end = c(F), during = T, frac = c(0)
  )) |>
  bind_rows(expand_grid(
    window = c(200, 250, 300, 350, 375, 400, 425, 450, 500, 600, 700, 800, 900, 1000),
    time_0 = c(T), time_end = c(T), during = T, frac = c(1)
  ))

rts <- rle_data %>%
  group_by(administration_id, trial_id, trial_order) %>%
  nest() |>
  cross_join(grid_options) |>
  mutate(rts = pmap(
    list(data, time_0, window, time_end, during, frac),
    \(d, t0, w, te, dur, fr){
      print(window)
      get_rt(d,
        t_0 = t0, window_length = w,
        t_end = te, window_mostly_region = dur, mostly_fraction = fr
      )
    }
  )) |>
  select(-data) |>
  unnest(cols = c(rts)) |>
  left_join(d_aoi %>%
    select(administration_id, dataset_name, subject_id, trial_id, trial_order, target_label) %>%
    distinct())

saveRDS(rts, here("cached_intermediates", "4_rts.rds"))
```

```{r}
library(multidplyr)

cluster <- new_cluster(8)
cluster_library(cluster, "dplyr")
cluster_library(cluster, "stringr")
cluster_library(cluster, "purrr")
cluster_library(cluster, "tidyr")
cluster_library(cluster, "agreement")
cluster_copy(cluster, "get_icc")

rts <- readRDS(here("cached_intermediates", "4_rts.rds"))

d_rt_dt <- rts |>
  filter(shift_type == "D-T") |>
  mutate(
    land_rt = rt,
    first_launch_rt = shift_start_rt,
    # last_launch_rt = last_shift_rt
  ) |>
  mutate(
    across(c("land_rt", "first_launch_rt"), log, .names = "log_{.col}"),
    across(
      c(
        "land_rt", "first_launch_rt",
        "log_land_rt", "log_first_launch_rt",
      ),
      ~ ifelse(shift_length <= 600, .x, NA),
      .names = "trim_first_{.col}"
    ),
    across(
      c(
        "land_rt", # "last_launch_rt",
        "log_land_rt", # "log_last_launch_rt"
      ),
      ~ ifelse(last_shift_length <= 600, .x, NA),
      .names = "trim_last_{.col}"
    )
  ) |>
  select(-rt, -shift_start_rt, -last_shift_rt) |>
  group_by(dataset_name, time_0, window, time_end, during, frac, administration_id, target_label) |>
  mutate(repetition = row_number())


rt_iccs <- d_rt_dt |>
  group_by(dataset_name, time_0, window, time_end, during, frac) |>
  nest() |>
  partition(cluster) |>
  mutate(icc_admin = map(data, \(d) {
    rt_names <- colnames(d)[str_ends(colnames(d), "rt")]
    n_total <- map_dbl(rt_names, \(rt_col) {
      d |>
        filter(!is.na(d[rt_col])) |>
        nrow()
    })
    n_admin <- map_dbl(rt_names, \(rt_col) {
      d |>
        filter(!is.na(d[rt_col])) |>
        select(administration_id) |>
        unique() |>
        nrow()
    })
    icc_values <- map_dbl(rt_names, \(rt_col) {
      get_icc(d |> filter(!is.na(d[rt_col])), column = rt_col, object = "administration")
    })
    tibble(measure = rt_names, icc = icc_values, n_total = n_total, n_admin = n_admin)
  })) |>
  collect() |>
  select(-data) |>
  unnest(icc_admin)

saveRDS(rt_iccs, here("cached_intermediates", "rt_iccs.rds"))
```

# Measure 3: Reaction time


IV analysis options:
* what time point to use for RT -- the first time you leave, the last time you leave before landing, when you land
* raw vs log 
* filter by max shift length
* filter min start time
* do we exclude based on pre-min loss (between t_0 and min start time)

outcome measures:
* reliability = ICC
* data loss = how many datapoints are kept

## how often does it matter?

```{r}
d_rt <- readRDS(here("cached_intermediates", "4_rts.rds")) |> filter(window == 0, time_0 == T)
```
 
 here we're looking at D-T transitions, where the child was on D at time 0
 
### time point to use for RT + max shift length


```{r}
ggplot(d_rt, aes(x = shift_start_rt, y = rt)) +
  geom_point(alpha = .1) +
  geom_smooth(method = "lm")

ggplot(
  d_rt,
  aes(x = shift_start_rt, y = rt)
) +
  geom_point(alpha = .1) +
  geom_point(
    data = filter(d_rt, shift_length > 600),
    col = "red"
  ) +
  geom_smooth(method = "lm")
```

this is filtering at 600ms based on first leaving distractor

```{r}
# does type of start initiation matter

d_rt |>
  ungroup() |>
  filter(!is.na(shift_start_rt)) |>
  mutate(
    initiation_type_matters = shift_start_rt != last_shift_rt,
    long_shift_occurs = shift_length > 600
  ) |>
  group_by(initiation_type_matters, long_shift_occurs) |>
  tally() |>
  ungroup() |>
  mutate(pct = n / sum(n))
```
for the most part, these combos won't matter because >95% of the data has the kid only leaving once and doesn't have a long shift. 

distribution of shift lengths -- cut off at 1000ms; by far most shifts are <250ms

```{r}
d_rt |> ggplot(aes(x = shift_length)) +
  geom_histogram(binwidth = 50) +
  coord_cartesian(xlim = c(0, 1000))
d_rt |> ggplot(aes(x = last_shift_length)) +
  geom_histogram(binwidth = 50) +
  coord_cartesian(xlim = c(0, 1000))
```
### how important is consistency in 0-400ms window
how much of the time are kids looking at the same thing between 0 and 400 ms -- many studies require looks to distractor + no shifts for 250/300/367 ms; how much data loss is coming from this?

```{r}
d_aoi <- readRDS(here("cached_intermediates", "1_d_aoi.Rds"))

t_0 <- d_aoi |>
  filter(t_norm == 0) |>
  mutate(t_0_aoi = aoi) |>
  select(administration_id, trial_id, dataset_name, t_0_aoi) |>
  mutate(t_0_aoi = ifelse(t_0_aoi %in% c("target", "distractor"), t_0_aoi, "other"))
t_375 <- d_aoi |>
  filter(t_norm == 375) |>
  mutate(t_375_aoi = aoi) |>
  select(administration_id, trial_id, dataset_name, t_375_aoi) |>
  mutate(t_375_aoi = ifelse(t_375_aoi %in% c("target", "distractor"), t_375_aoi, "other"))
early_dist <- d_aoi |>
  filter(t_norm < 400 & t_norm >= 0) |>
  group_by(administration_id, trial_id, dataset_name, aoi) |>
  tally() |>
  left_join(t_0) |>
  left_join(t_375) |>
  pivot_wider(names_from = aoi, values_from = n, values_fill = 0) |>
  mutate(type = case_when(
    target + distractor + missing + other != 16 ~ "some missing ts",
    target == 16 ~ "only target",
    distractor == 16 ~ "only distractor",
    missing + other == 16 ~ "all off",
    target == 0 & distractor > 8 ~ "d+m (mostly d)",
    target == 0 ~ "d+m (mostly m)",
    distractor == 0 & target > 8 ~ "t+m (mostly t)",
    distractor == 0 ~ "t+m (mostly m)",
    T ~ "both"
  ))

ggplot(early_dist, aes(x = t_0_aoi, fill = type)) +
  facet_wrap(~t_375_aoi) +
  geom_bar()

early_dist |>
  group_by(type, t_0_aoi, t_375_aoi) |>
  tally() |>
  ungroup() |>
  mutate(pct = round(n / sum(n), 3)) |>
  arrange(desc(pct))
```
we want to know of the ones that are on t/d/m at start

~33% is on distractor for 0-375
~32% is on target for 0-375

~10% is missing/other for 0-375(this is going to get tossed in all cases!)

~5.5% goes from d to t
~5.5% goes from t to d 

~5.5% is mostly on d during the time, with some being on other (at start/end/middle)
~4.5% is mostly on t during the time, with some being on other (at start/end/middle)

to look at:
* when we have d/other or t/other what's the typical patterns
  * how much is other & when
* for both t/d this probably can't be salvaged but look at patterns

```{r}
early_dist |>
  filter(target == 0) |>
  filter(missing + other < 16) |>
  filter(distractor != 16) |>
  ggplot(aes(x = distractor)) +
  geom_bar()

early_dist |>
  filter(distractor == 0) |>
  filter(missing + other < 16) |>
  filter(target != 16) |>
  ggplot(aes(x = target)) +
  geom_bar()
```
so, most of the d/m or t/m mixes is heavily weighted to d or t with only a little m.
when does this m occur?
```{r}
d_aoi |>
  filter(t_norm < 400 & t_norm >= 0) |>
  inner_join(early_dist |> filter(target == 0) |> filter(missing + other < 16) |> filter(distractor != 16) |> select(administration_id, dataset_name, trial_id, num_distractor = distractor)) |>
  mutate(is_distractor = ifelse(aoi == "distractor", 1, 0)) |>
  group_by(t_norm, num_distractor) |>
  summarize(is_distractor = mean(is_distractor)) |>
  ggplot(aes(x = t_norm, y = is_distractor, col = num_distractor, group = num_distractor)) +
  geom_point() +
  geom_line() +
  scale_color_viridis()
```
so, most of the d/m that is mostly d has the m at the beginning or end (rather than in the middle) -- possibly this is just because of how fixations work? 
this is especially true when d is >11 or so, which is most of this chunk of data. 

```{r}
d_aoi |>
  filter(t_norm < 400 & t_norm >= 0) |>
  inner_join(early_dist |> filter(distractor == 0) |> filter(missing + other < 16) |> filter(target != 16) |> select(administration_id, dataset_name, trial_id, num_target = target)) |>
  mutate(is_target = ifelse(aoi == "target", 1, 0)) |>
  group_by(t_norm, num_target) |>
  summarize(is_target = mean(is_target)) |>
  ggplot(aes(x = t_norm, y = is_target, col = num_target, group = num_target)) +
  geom_point() +
  geom_line() +
  scale_color_viridis()
```
what about when there is both t and d?

I think all we're seeing here is autocorrelation, and also not sure how to deal with 3 way data. 

```{r}
d_aoi |>
  filter(t_norm < 400 & t_norm >= 0) |>
  inner_join(early_dist |> filter(distractor > 0) |> filter(missing + other < 16) |> filter(target > 0) |> select(administration_id, dataset_name, trial_id, num_target = target, num_distractor = distractor)) |>
  mutate(distractor_target = case_when(
    aoi == "target" ~ 1,
    aoi == "distractor" ~ 0,
    T ~ NA
  )) |>
  group_by(t_norm, num_target) |>
  summarize(distractor_target = mean(distractor_target, na.rm = T)) |>
  ggplot(aes(x = t_norm, y = distractor_target, col = num_target, group = num_target)) +
  geom_point() +
  geom_line() +
  scale_color_viridis()

d_aoi |>
  filter(t_norm < 400 & t_norm >= 0) |>
  inner_join(early_dist |> filter(distractor > 0) |> filter(missing + other < 16) |> filter(target > 0) |> select(administration_id, dataset_name, trial_id, num_target = target, num_distractor = distractor)) |>
  mutate(distractor_target = case_when(
    aoi == "target" ~ 1,
    aoi == "distractor" ~ 0,
    T ~ NA
  )) |>
  group_by(t_norm, num_distractor) |>
  summarize(distractor_target = mean(distractor_target, na.rm = T)) |>
  ggplot(aes(x = t_norm, y = distractor_target, col = num_distractor, group = num_distractor)) +
  geom_point() +
  geom_line() +
  scale_color_viridis()
```
Take-aways from data-viz:
* most of the data is reasonably behaved 30% T-T, 30% D-D, we're looking at whether we can save another like 5%ish onto either by relaxing early missing data requirements
* for other exclusions around long-shift, again, not much data is being affected (maybe 5% but some of this is also going to overlap more with data that has other issues)

reasonable options for where looking when:
* at t=0 at D (nothing else)
* during window (of variable window length), only looking at D 
* during window (of variable window length), not looking at T 
* during window (of variable window length), not looking at T and looking at D 3/4+ of the time (or other fraction -- traditional analyses use 1)
* at t=0 at D & during window (of variable window length), not looking at T (window {100, 200, 300, 400})
* at t=0 at D & * during window (of variable window length), not looking at T and looking at D 3/4+ of the time (window {100, 200, 300, 400})

so maybe the combinatorics are:

always: during window no looking at T
* looking at D at t=0 (yes/no)
* window length {100, 200, 300, 400}
* looking at D at t=end of window (yes,no)
* looking at D 3/4+ of the time during the window (or other fraction)

## Analyse

We consider a few different options for how to get RTs
All of these are framed as D-T but same would apply for T-D

* we consider RTs measured either from the first time you leave D (first_launch) or the first time you arrive at T (land) [theoretically, the last time you leave D is another option, that was tried in an earlier iteration, but dropped here for tractability -- see descriptives above for this only mattering in a limited number of cases]
* raw v log RT -- here everything is raw, but we can re-address log for the top few
* the option to trim overly long shifts to 600ms either calculated from first leaving or final leaving

how do we determine that the kid is sufficiently on D at the relevant time:
* "relevant time" = window length in ms where they have to be not on T and potentially meet other constraints (below)
* time_0 -- do they have to be on D or just *not* on T
* window_end -- at the end of the window, do they have to be on D or just *not* on T
* fraction -- the minimum fraction of the time during the window that they have to be on D

```{r}
rt_iccs <- readRDS(here("cached_intermediates", "4_rt_iccs.rds"))

rt_iccs$dataset_name <- fct_reorder(rt_iccs$dataset_name, rt_iccs$icc)

rt_iccs_coded <- rt_iccs |> mutate(
  type = case_when(
    str_detect(measure, "first_launch_rt") ~ "first_launch",
    str_detect(measure, "last_launch_rt") ~ "last_launch",
    str_detect(measure, "land_rt") ~ "land"
  ),
  logged = case_when(
    str_detect(measure, "log") ~ "log",
    T ~ "raw"
  ),
  trimming = case_when(
    str_detect(measure, "trim_first") ~ "trim_first",
    str_detect(measure, "trim_last") ~ "trim_last",
    T ~ "untrimmed"
  )
)


rt_iccs_coded |> View()
```

```{r}
rt_iccs_summ <- rt_iccs_coded |>
  group_by(type, logged, trimming, window, time_0, time_end, during, frac) |>
  summarize(mean_icc = mean(icc, na.rm = T), datapoints = sum(n_total))

rt_iccs_summ |>
  arrange(desc(mean_icc)) |>
  head(20) |>
  knitr::kable()
```
so, we have a lot of combos to look at. 
```{r}
rt_iccs_summ |> ggplot(aes(x = str_c(logged, "_", type), y = mean_icc, group = interaction(type, logged, trimming))) +
  geom_point(aes(col = trimming), position = position_dodge(width = .4)) +
  stat_summary(position = position_dodge(width = .4)) +
  coord_flip() +
  geom_hline(yintercept = .65) +
  scale_color_brewer(type = "qual", palette = 1)
```



```{r}
rt_iccs_summ |>
  ggplot(aes(x = window, y = mean_icc)) +
  geom_point(aes(col = window), position = position_dodge(width = .4)) +
  stat_summary(position = position_dodge(width = .4)) +
  coord_flip() +
  geom_hline(yintercept = .65) +
  scale_color_viridis()
```
we tried a lot of different window options, some of which we thought were likely to be bad, but here we can see that the "good" options are in the 250-500 range, so we'll focus there. 


```{r}
rt_iccs_summ |>
  filter(window >= 250, window <= 500) |>
  ggplot(aes(x = str_c("window_end", time_end), y = mean_icc, group = interaction(time_0, time_end, window))) +
  geom_point(aes(col = window), position = position_dodge(width = .4)) +
  stat_summary(position = position_dodge(width = .4)) +
  coord_flip() +
  facet_wrap(~ str_c("time_0", time_0)) +
  geom_hline(yintercept = .65) +
  scale_color_viridis()
```
generally having both window start and end be true is best (I think?).

looking specifically at 400, what about fraction 
```{r}
rt_iccs_summ |>
  filter(window %in% c(400)) |>
  ggplot(aes(x = str_c("window_end", time_end), y = mean_icc, group = interaction(time_0, time_end, frac))) +
  geom_point(aes(col = as.character(frac)), position = position_dodge(width = .4)) +
  stat_summary(position = position_dodge(width = .4)) +
  coord_flip() +
  facet_wrap(~ str_c("time_0", time_0)) +
  geom_hline(yintercept = .65)
```
looking within the 400 window, looks like both start and end being true is important, but not the type of during. 

```{r}
rt_iccs_summ |>
  filter(time_0, time_end, frac %in% c(0, 1)) |>
  filter(window >= 200, window <= 600) |>
  ggplot(aes(x = window, y = mean_icc, group = interaction(time_0, time_end, window))) +
  geom_point(aes(col = window), position = position_dodge(width = .4)) +
  stat_summary(position = position_dodge(width = .4)) +
  geom_hline(yintercept = .65) +
  facet_wrap(~frac) +
  scale_color_viridis()
```
so somewhere in the 375 to 500 looks best, probably doesn't matter whether you're on the whole time as long as you're on start and end. 

```{r}
rt_iccs_summ |>
  filter(time_0, time_end, frac %in% c(0, 1)) |>
  filter(window >= 375, window <= 500) |>
  ggplot(aes(x = str_c(logged, "_", type), y = mean_icc, group = interaction(type, logged, trimming))) +
  geom_point(aes(col = trimming), position = position_dodge(width = .4)) +
  stat_summary(position = position_dodge(width = .4)) +
  coord_flip() +
  geom_hline(yintercept = .65) +
  scale_color_brewer(type = "qual", palette = 1)
```
looking again, at 400, land + untrimmed seems fine!


```{r}
rt_iccs_summ |>
  filter(time_0, time_end) |>
  filter(frac %in% c(0, 1)) |>
  filter(window >= 375, window <= 500) |>
  filter(type == "land") |>
  filter(trimming == "untrimmed") |>
  ggplot(aes(x = window, y = mean_icc, group = interaction(time_0, time_end, window))) +
  geom_point(aes(col = window), position = position_dodge(width = .4)) +
  geom_hline(yintercept = .65) +
  scale_color_viridis()
```
so, best options seem to be 
time_0 = T
time_end = T
window = sometime in 375-500
land
untrimmed is fine 
don't bother about fraction





```{r}
comparison <- rt_iccs_coded |>
  filter(time_0 == T, time_end == T) |>
  filter(frac %in% c(0, 1)) |>
  filter(window >= 350, window <= 500) |>
  filter(trimming %in% c("trim_first", "untrimmed")) |>
  mutate(approach = case_when(
    type == "land" & trimming == "untrimmed" & frac == "0" ~ "generous",
    type == "land" & trimming == "untrimmed" & frac == "1" ~ "trad_land",
    type == "first_launch" & trimming == "trim_first" & frac == "1" ~ "trad_launch"
  )) |>
  filter(!is.na(approach))

comparison |>
  ggplot(aes(x = approach, y = icc)) +
  geom_point(aes(col = window, shape = logged), position = position_dodge(width = .4)) +
  coord_flip() +
  geom_hline(yintercept = .65) +
  scale_color_viridis() +
  facet_wrap(~dataset_name)

comparison |>
  filter(window == 375) |>
  ggplot(aes(x = approach, y = icc)) +
  geom_point(aes(col = window, shape = logged), position = position_dodge(width = .4)) +
  coord_flip() +
  geom_hline(yintercept = .65) +
  scale_color_viridis() +
  facet_wrap(~dataset_name)

comparison |>
  filter(approach == "generous") |>
  ggplot(aes(x = window, y = icc)) +
  geom_point(aes(col = window, shape = logged), position = position_dodge(width = .4)) +
  coord_flip() +
  geom_hline(yintercept = .65) +
  scale_color_viridis()
```
I don't know what's up with pomper for the trad_launch. 

Raw v log seems to go both ways, ideally we'd probably want something that works well for both

Window again 375-500 ish seems reasonable, 400 seems like a fine compromise

Mostly, it probably doesn't matter, modulo a few dataset abnormalities 


### bootstrapping

```{r, eval=F}
library(multidplyr)

cluster <- new_cluster(16)
cluster_library(cluster, "dplyr")
cluster_library(cluster, "stringr")
cluster_library(cluster, "purrr")
cluster_library(cluster, "tidyr")
cluster_library(cluster, "agreement")
cluster_copy(cluster, "bootstrap_icc")

rts <- readRDS("rts.rds")

d_rt_dt <- rts |>
  filter(window %in% c(200, 350, 375, 400, 425, 450, 500)) |>
  filter(frac %in% c(0, 1)) |>
  filter(time_0 == T, time_end == T) |>
  filter(shift_type == "D-T") |>
  mutate(
    land_rt = rt,
    first_launch_rt = shift_start_rt,
    # last_launch_rt = last_shift_rt
  ) |>
  mutate(
    across(c("land_rt", "first_launch_rt"), log, .names = "log_{.col}"),
    across(
      c(
        "land_rt", "first_launch_rt",
        "log_land_rt", "log_first_launch_rt",
      ),
      ~ ifelse(shift_length <= 600, .x, NA),
      .names = "trim_first_{.col}"
    ),
  ) |>
  select(-rt, -shift_start_rt, -last_shift_rt) |>
  group_by(dataset_name, time_0, window, time_end, during, frac, administration_id, target_label) |>
  mutate(repetition = row_number())


rt_iccs <- d_rt_dt |>
  group_by(dataset_name, time_0, window, time_end, during, frac) |>
  nest() |>
  partition(cluster) |>
  mutate(icc_admin = map(data, \(d) {
    rt_names <- colnames(d)[str_ends(colnames(d), "rt")]
    n_total <- map_dbl(rt_names, \(rt_col) {
      d |>
        filter(!is.na(d[rt_col])) |>
        nrow()
    })
    n_admin <- map_dbl(rt_names, \(rt_col) {
      d |>
        filter(!is.na(d[rt_col])) |>
        select(administration_id) |>
        unique() |>
        nrow()
    })
    icc_values <- map(rt_names, \(rt_col) {
      bootstrap_icc(d |> filter(!is.na(d[rt_col])), column = rt_col, bootstrap = 2000)
    })
    tibble(
      measure = rt_names, foo = icc_values,
      n_total = n_total, n_admin = n_admin
    )
    # icc_values
  })) |>
  collect() |>
  select(-data) |>
  unnest(icc_admin) |>
  unnest(foo)

saveRDS(rt_iccs, here("cached_intermediates", "4_rt_iccs_boot.rds"))
```

```{r}
rt_boot <- readRDS(here("cached_intermediates", "4_rt_iccs_boot.rds")) |>
  mutate(
    type = case_when(
      str_detect(measure, "first_launch_rt") ~ "first_launch",
      str_detect(measure, "last_launch_rt") ~ "last_launch",
      str_detect(measure, "land_rt") ~ "land"
    ),
    logged = case_when(
      str_detect(measure, "log") ~ "log",
      T ~ "raw"
    ),
    trimming = case_when(
      str_detect(measure, "trim_first") ~ "trim_first",
      str_detect(measure, "trim_last") ~ "trim_last",
      T ~ "untrimmed"
    )
  ) |>
  mutate(approach = case_when(
    type == "land" & trimming == "untrimmed" & frac == "0" ~ "generous",
    type == "land" & trimming == "untrimmed" & frac == "1" ~ "trad_land",
    type == "first_launch" & trimming == "trim_first" & frac == "1" ~ "trad_launch"
  )) |>
  filter(!is.na(approach))

rt_boot_summ <- rt_boot |>
  filter(!is.na(lower), !is.na(upper)) |>
  mutate(
    stdev = (upper - lower) / (1.96 * 2),
    var = stdev**2
  ) |>
  group_by(window, during, logged, approach) |>
  nest() |>
  mutate(icc = map(data, \(d){
    rma(d$est, d$var) |>
      summary() |>
      coef()
  })) |>
  select(-data) |>
  unnest(icc)

rt_boot_summ |> ggplot(aes(x = approach, color = as.character(window), y = estimate, ymin = ci.lb, ymax = ci.ub)) +
  geom_pointrange(position = position_dodge(width = .5)) +
  coord_flip() +
  facet_wrap(~logged) +
  scale_color_viridis(discrete = T)

rt_boot_summ |> ggplot(aes(x = approach, color = approach, y = estimate, ymin = ci.lb, ymax = ci.ub)) +
  geom_pointrange() +
  coord_flip() +
  facet_grid(window ~ logged)

rt_boot |>
  filter(window == 400, logged == "raw") |>
  ggplot(aes(x = approach, color = approach, y = est, ymin = lower, ymax = upper)) +
  geom_pointrange() +
  coord_flip() +
  facet_wrap(~dataset_name)

rt_boot |>
  filter(window == 400, logged == "log") |>
  ggplot(aes(x = approach, color = approach, y = est, ymin = lower, ymax = upper)) +
  geom_pointrange() +
  coord_flip() +
  facet_wrap(~dataset_name)
```

```{r}
trials_per_dataset <- d_aoi |> distinct(trial_id, dataset_name) |> group_by(dataset_name) |> tally()

data_retained <- readRDS(here("cached_intermediates", "4_rt_iccs_boot.rds")) |>
  mutate(
    type = case_when(
      str_detect(measure, "first_launch_rt") ~ "first_launch",
      str_detect(measure, "last_launch_rt") ~ "last_launch",
      str_detect(measure, "land_rt") ~ "land"
    ),
    logged = case_when(
      str_detect(measure, "log") ~ "log",
      T ~ "raw"
    ),
    trimming = case_when(
      str_detect(measure, "trim_first") ~ "trim_first",
      str_detect(measure, "trim_last") ~ "trim_last",
      T ~ "untrimmed"
    )
  ) |>
  mutate(approach = case_when(
    type == "land" & trimming == "untrimmed" & frac == "0" ~ "generous",
    type == "land" & trimming == "untrimmed" & frac == "1" ~ "trad_land",
    type == "first_launch" & trimming == "trim_first" & frac == "1" ~ "trad_launch"
  )) |>
  filter(!is.na(approach)) |> left_join(trials_per_dataset) |> 
  mutate(pct_retained=n_total/n)

library(metafor)
data_retained_summ <- rt_boot |>
  filter(!is.na(lower), !is.na(upper)) |>
  mutate(
    stdev = (upper - lower) / (1.96 * 2),
    var = stdev**2
  ) |>
  group_by(window, during, logged, approach) |>
  nest() |>
  mutate(icc = map(data, \(d){
    rma(d$est, d$var) |>
      summary() |>
      coef()
  }),
  mean_pct=map(data, \(d) mean(d$pct_retained))) |>
  select(-data) |>
  unnest(icc, mean_pct)


ggplot(data_retained, aes(x=pct_retained, y=est, ymin=lower, ymax=upper, color=as.character(window)))+geom_pointrange()+coord_flip()+facet_wrap(~as.character(window))+scale_color_viridis(discrete=T)

ggplot(data_retained, aes(x=pct_retained, y=est, ymin=lower, ymax=upper, color=approach))+geom_pointrange()+facet_grid(logged~approach)+coord_flip()+theme(legend.position = "none")+geom_smooth(color="black")

ggplot(data_retained, aes(x=pct_retained, y=est, ymin=lower, ymax=upper, color=approach))+geom_pointrange()+coord_flip()+theme(legend.position = "none")+geom_smooth(color="black")

ggplot(data_retained_summ, aes(x=mean_pct, y=estimate, ymin=ci.lb, ymax=ci.ub))+geom_pointrange(aes(color=approach))+geom_smooth()+coord_flip()

ggplot(data_retained_summ, aes(x=mean_pct, y=estimate, ymin=ci.lb, ymax=ci.ub))+geom_pointrange(aes(color=as.character(window)))+geom_smooth()+coord_flip()+scale_color_viridis(discrete=T)

ggplot(data_retained, aes(y=pct_retained, x=reorder(dataset_name, pct_retained)))+geom_point()+coord_flip()
```



### age split half 

```{r}
source("cl_helper.R")
library(multidplyr)

cluster <- new_cluster(16)
cluster_library(cluster, "dplyr")
cluster_library(cluster, "stringr")
cluster_library(cluster, "purrr")
cluster_library(cluster, "tidyr")
cluster_library(cluster, "agreement")
cluster_copy(cluster, "bootstrap_icc")

rts <- readRDS("rts.rds")
d_aoi <- readRDS("d_aoi.Rds")
d_rt_dt <- rts |>
  left_join(d_aoi |> select(age, administration_id) |> distinct()) |>
  filter(window %in% c(200, 350, 375, 400, 425, 450, 500)) |>
  filter(frac %in% c(0, 1)) |>
  filter(time_0 == T, time_end == T) |>
  filter(shift_type == "D-T") |>
  mutate(
    land_rt = rt,
    first_launch_rt = shift_start_rt,
    # last_launch_rt = last_shift_rt
  ) |>
  mutate(
    across(c("land_rt", "first_launch_rt"), log, .names = "log_{.col}"),
    across(
      c(
        "land_rt", "first_launch_rt",
        "log_land_rt", "log_first_launch_rt",
      ),
      ~ ifelse(shift_length <= 600, .x, NA),
      .names = "trim_first_{.col}"
    ),
  ) |>
  select(-rt, -shift_start_rt, -last_shift_rt) |>
  mutate(younger = age < 24) |>
  group_by(dataset_name, time_0, window, time_end, during, frac, administration_id, target_label, younger) |>
  mutate(repetition = row_number())


rt_iccs_age <- d_rt_dt |>
  group_by(dataset_name, younger, time_0, window, time_end, during, frac) |>
  nest() |>
  partition(cluster) |>
  mutate(icc_admin = map(data, \(d) {
    rt_names <- colnames(d)[str_ends(colnames(d), "rt")]
    n_total <- map_dbl(rt_names, \(rt_col) {
      d |>
        filter(!is.na(d[rt_col])) |>
        nrow()
    })
    n_admin <- map_dbl(rt_names, \(rt_col) {
      d |>
        filter(!is.na(d[rt_col])) |>
        select(administration_id) |>
        unique() |>
        nrow()
    })
    icc_values <- map(rt_names, \(rt_col) {
      bootstrap_icc(d |> filter(!is.na(d[rt_col])), column = rt_col, bootstrap = 2000)
    })
    tibble(
      measure = rt_names, foo = icc_values,
      n_total = n_total, n_admin = n_admin
    )
    # icc_values
  })) |>
  collect() |>
  select(-data) |>
  unnest(icc_admin) |>
  unnest(foo)

saveRDS(rt_iccs_age, here("cached_intermediates", "4_rt_iccs_age_boot.rds"))

```


```{r}
rt_age_boot <- readRDS(here("cached_intermediates", "4_rt_iccs_age_boot.rds")) |>
  mutate(
    type = case_when(
      str_detect(measure, "first_launch_rt") ~ "first_launch",
      str_detect(measure, "last_launch_rt") ~ "last_launch",
      str_detect(measure, "land_rt") ~ "land"
    ),
    logged = case_when(
      str_detect(measure, "log") ~ "log",
      T ~ "raw"
    ),
    trimming = case_when(
      str_detect(measure, "trim_first") ~ "trim_first",
      str_detect(measure, "trim_last") ~ "trim_last",
      T ~ "untrimmed"
    )
  ) |>
  mutate(approach = case_when(
    type == "land" & trimming == "untrimmed" & frac == "0" ~ "generous",
    type == "land" & trimming == "untrimmed" & frac == "1" ~ "trad_land",
    type == "first_launch" & trimming == "trim_first" & frac == "1" ~ "trad_launch"
  )) |>
  filter(!is.na(approach)) |> 
  mutate(younger=ifelse(younger, "<24months", ">=24months"))

rt_age_boot_summ <- rt_age_boot |>
  filter(!is.na(lower), !is.na(upper)) |>
  mutate(
    stdev = (upper - lower) / (1.96 * 2),
    var = stdev**2
  ) |>
  group_by(window, during, logged, approach, younger) |>
  nest() |>
  mutate(icc = map(data, \(d){
    rma(d$est, d$var, control=list(stepadj=0.5)) |>
      summary() |>
      coef()
  })) |>
  select(-data) |>
  unnest(icc)

rt_age_boot_summ |> ggplot(aes(x = approach, color = as.character(window), y = estimate, ymin = ci.lb, ymax = ci.ub)) +
  geom_pointrange(position = position_dodge(width = .5)) +
  coord_flip() +
  facet_grid(younger~logged) +
  scale_color_viridis(discrete = T)

rt_age_boot_summ |> ggplot(aes(x = str_c(approach,"_", logged), color = approach, y = estimate, ymin = ci.lb, ymax = ci.ub)) +
  geom_pointrange() +
  coord_flip() +
  facet_grid(window ~ younger)

rt_age_boot |>
  filter(window == 400, logged == "raw") |>
  ggplot(aes(x = approach, color = younger, y = est, ymin = lower, ymax = upper)) +
  geom_pointrange() +
  coord_flip() +
  facet_wrap(~dataset_name)

rt_age_boot |>
  filter(window == 400, logged == "log") |>
  ggplot(aes(x = approach, color = younger, y = est, ymin = lower, ymax = upper)) +
  geom_pointrange() +
  coord_flip() +
  facet_wrap(~dataset_name)
```


## Validity

### set up CDI bootstrapping

```{r}
do_cdi_rt <- function(data, indices) {
  summ <- data |>
    slice(indices) |>
    group_by(administration_id) |>
    summarize(rt = mean(rt, na.rm = T)) |>
    left_join(cdi_data) |>
    ungroup() |>
    summarise(
      cor_comp = ifelse(sum(!is.na(comp) & !is.na(rt)) > 2, cor.test(rt, comp)$estimate, as.numeric(NA)),
      cor_prod = ifelse(sum(!is.na(prod) & !is.na(rt)) > 2, cor.test(rt, prod)$estimate, as.numeric(NA)),
      cor_age = ifelse(sum(!is.na(age) & !is.na(rt)) > 2, cor.test(rt, age)$estimate, as.numeric(NA))
    )
  cors <- c(summ$cor_comp[1], summ$cor_prod[1], summ$cor_age[1])
  names(cors) <- c("cor_comp", "cor_prod", "cor_age")

  return(cors)
}



cluster <- new_cluster(16)
cluster_library(cluster, "dplyr")
cluster_library(cluster, "stringr")
cluster_library(cluster, "purrr")
cluster_library(cluster, "tidyr")
cluster_library(cluster, "stats")
cluster_library(cluster, "tibble")
# cluster_library(cluster, "agreement")
# cluster_copy(cluster, "bootstrap_icc")
cluster_copy(cluster, "do_cdi_rt")
cluster_copy(cluster, "cdi_data")

rts <- readRDS("rts.rds")


d_rt_dt <- rts |>
  filter(window %in% c(200, 350, 375, 400, 425, 450, 500)) |>
  filter(frac %in% c(0, 1)) |>
  filter(time_0 == T, time_end == T) |>
  filter(shift_type == "D-T") |>
  mutate(
    land_rt = rt,
    first_launch_rt = shift_start_rt,
    # last_launch_rt = last_shift_rt
  ) |>
  mutate(
    across(c("land_rt", "first_launch_rt"), log, .names = "log_{.col}"),
    across(
      c(
        "first_launch_rt",
        "log_first_launch_rt",
      ),
      ~ ifelse(shift_length <= 600, .x, NA),
      .names = "trim_first_{.col}"
    ),
  ) |>
  select(-rt, -shift_start_rt, -last_shift_rt) |>
  group_by(dataset_name, time_0, window, time_end, during, frac, administration_id, target_label)

d_rt_dt_long <- d_rt_dt |>
  pivot_longer(ends_with("rt"), names_to = "measure", values_to = "rt") |>
  mutate(
    type = case_when(
      str_detect(measure, "first_launch_rt") ~ "first_launch",
      str_detect(measure, "last_launch_rt") ~ "last_launch",
      str_detect(measure, "land_rt") ~ "land"
    ),
    logged = case_when(
      str_detect(measure, "log") ~ "log",
      T ~ "raw"
    ),
    trimming = case_when(
      str_detect(measure, "trim_first") ~ "trim_first",
      T ~ "untrimmed"
    )
  ) |>
  mutate(approach = case_when(
    type == "land" & trimming == "untrimmed" & frac == "0" ~ "generous",
    type == "land" & trimming == "untrimmed" & frac == "1" ~ "trad_land",
    type == "first_launch" & trimming == "trim_first" & frac == "1" ~ "trad_launch"
  )) |>
  filter(!is.na(approach))

bootstrap_cdi <- d_rt_dt_long |>
  ungroup() |>
  select(administration_id, rt, approach, window, logged, dataset_name) |>
  group_by(approach, window, logged, dataset_name) |>
  nest() |>
  partition(cluster) |>
  mutate(corr = map(data, \(d) {
    b <- boot::boot(d, do_cdi_rt, 2000)
    if (is.na(b$t0[1])) {
      comp_lower <- NA
      comp_upper <- NA
    } else {
      ci_comp <- boot::boot.ci(b, index = 1, type = "basic")
      comp_lower <- ci_comp$basic[4]
      comp_upper <- ci_comp$basic[5]
    }
    if (is.na(b$t0[2])) {
      prod_lower <- NA
      prod_upper <- NA
    } else {
      ci_prod <- boot::boot.ci(b, index = 2, type = "basic")
      prod_lower <- ci_prod$basic[4]
      prod_upper <- ci_prod$basic[5]
    }
    if (is.na(b$t0[3])) {
      age_lower <- NA
      age_upper <- NA
    } else {
      ci_age <- boot::boot.ci(b, index = 3, type = "basic")
      age_lower <- ci_age$basic[4]
      age_upper <- ci_age$basic[5]
    }
    tibble(
      comp_est = b$t0[1], comp_lower = comp_lower, comp_upper = comp_upper,
      prod_est = b$t0[2], prod_lower = prod_lower, prod_upper = prod_upper,
      age_est = b$t0[3], age_lower = age_lower, age_upper = age_upper,
    )
  })) |>
  collect() |>
  select(-data) |>
  unnest(corr)

saveRDS(bootstrap_cdi, "4_rt_cdi_boot.rds")

```

### analyse

```{r}
bootstrap_cdi <- readRDS(here("cached_intermediates", "4_rt_cdi_boot.rds"))

library(metafor)

bootstrap_cdi_summ <-  bootstrap_cdi |>
  mutate(
    comp_stdev = (comp_upper - comp_lower) / (1.96 * 2),
    comp_var = comp_stdev**2,
    prod_stdev = (prod_upper - prod_lower) / (1.96 * 2),
    prod_var = prod_stdev**2,
    age_stdev = (age_upper - age_lower) / (1.96 * 2),
    age_var = age_stdev**2
  ) |>
  group_by(approach, window, logged) |>
  nest() |>
  mutate(comp= map(data, \(d){
    rma(d$comp_est, d$comp_var) |>
      summary() |>
      coef()
  }),
  prod= map(data, \(d){
    rma(d$prod_est, d$prod_var) |>
      summary() |>
      coef()
  }),
  age= map(data, \(d){
    rma(d$age_est, d$age_var) |>
      summary() |>
      coef()
  })) |>
  select(-data) |>
  unnest(c(comp, prod, age), names_sep="_")

```
correlation with production: note that shorter RT are associated with more knowledge, so we expect negative correlations with production 

```{r}
bootstrap_cdi_summ |> ggplot(aes(x = str_c(approach, "_", logged), y = prod_estimate, ymin=prod_ci.lb, ymax=prod_ci.ub, color=as.character(window))) +geom_pointrange(position=position_dodge(width=.5))+
  scale_color_viridis(discrete=T)+
  coord_flip()


bootstrap_cdi |>filter(window==400) |> filter(!is.na(prod_est)) |>  ggplot(aes(x = str_c(approach, "_", logged), y = prod_est, ymin=prod_lower, ymax=prod_upper,  col=approach)) +
  geom_pointrange() +
  coord_flip() +
  theme(legend.position = "none") +
  facet_wrap(~dataset_name)
```

some effect based on window, but it looks like (when we look at the per-dataset data), that it's mostly driven by ferguson which has only 155 trial total (28 admins, 6 target labels), and here we're getting between 6 and 18 trials, which is low (and a really low data-retention rate!)


correlation with comprehension
```{r}
bootstrap_cdi_summ |> ggplot(aes(x = str_c(approach, "_", logged), y = comp_estimate, ymin=comp_ci.lb, ymax=comp_ci.ub, color=as.character(window))) +geom_pointrange(position=position_dodge(width=.5))+
  scale_color_viridis(discrete=T)+
  coord_flip()


bootstrap_cdi |>filter(window==400) |> filter(!is.na(comp_est)) |>  ggplot(aes(x = str_c(approach, "_", logged), y = comp_est, ymin=comp_lower, ymax=comp_upper,  col=approach)) +
  geom_pointrange() +
  coord_flip() +
  theme(legend.position = "none") +
  facet_wrap(~dataset_name)
```

correlation with age
```{r}
bootstrap_cdi_summ |> ggplot(aes(x = str_c(approach, "_", logged), y = age_estimate, ymin=age_ci.lb, ymax=age_ci.ub, color=as.character(window))) +geom_pointrange(position=position_dodge(width=.5))+
  scale_color_viridis(discrete=T)+
  coord_flip()


bootstrap_cdi |>filter(window==400) |> filter(!is.na(age_est)) |>  ggplot(aes(x = str_c(approach, "_", logged), y = age_est, ymin=age_lower, ymax=age_upper,  col=approach)) +
  geom_pointrange() +
  coord_flip() +
  theme(legend.position = "none") +
  facet_wrap(~dataset_name)
```

# Test-retest

```{r}
source("cl_helper.R")

d_aoi <- readRDS("d_aoi.Rds")
library(tibble)
library(multidplyr)

cdi_data <- readRDS("cdi.rds")

admins <- d_aoi |>
  select(dataset_name, subject_id, administration_id, age) |>
  distinct()
repeated <- admins |>
  group_by(dataset_name, subject_id) |>
  tally() |>
  filter(n > 1)

repeated_subjects <- admins |> inner_join(repeated)
# identify pairs
# hmm, sometimes we have times with 3+ 1 month apart,
# for now allow all the pairs that result so like 14-15 and 15-16 for the same kid

pairs <- repeated_subjects |>
  group_by(dataset_name, subject_id) |>
  mutate(
    forward_age = lead(age),
    forward_diff = forward_age - age,
    test_num = case_when(
      forward_diff < 1.5 ~ 1,
    ),
    mean_age = case_when(
      test_num == 1 ~ (age + forward_age) / 2,
    ),
    second_admin = case_when(
      test_num == 1 ~ lead(administration_id)
    )
  ) |>
  filter(!is.na(test_num)) |>
  rename(first_admin = administration_id) |>
  select(-n, -age) |>
  left_join(repeated_subjects |> select(-age, -n), by = c("dataset_name", "subject_id", "second_admin" = "administration_id")) |>
  ungroup() |>
  mutate(pair_number = row_number()) |>
  select(-forward_age, -forward_diff, -test_num)

pairs_long <- pairs |> pivot_longer(c("first_admin", "second_admin"), names_to = "session_num", values_to = "administration_id")

rt_data <- readRDS("rts.rds")


d_rt_dt <- rt_data |>
  filter(window %in% c(200, 350, 375, 400, 425, 450, 500)) |>
  filter(frac %in% c(0, 1)) |>
  filter(time_0 == T, time_end == T) |>
  filter(shift_type == "D-T") |>
  mutate(
    land_rt = rt,
    first_launch_rt = shift_start_rt,
    # last_launch_rt = last_shift_rt
  ) |>
  mutate(
    across(c("land_rt", "first_launch_rt"), log, .names = "log_{.col}"),
    across(
      c(
        "first_launch_rt",
        "log_first_launch_rt",
      ),
      ~ ifelse(shift_length <= 600, .x, NA),
      .names = "trim_first_{.col}"
    ),
  ) |>
  select(-rt, -shift_start_rt, -last_shift_rt) |>
  group_by(dataset_name, time_0, window, time_end, during, frac, administration_id, target_label)

d_rt_dt_long <- d_rt_dt |>
  pivot_longer(ends_with("rt"), names_to = "measure", values_to = "rt") |>
  mutate(
    type = case_when(
      str_detect(measure, "first_launch_rt") ~ "first_launch",
      str_detect(measure, "last_launch_rt") ~ "last_launch",
      str_detect(measure, "land_rt") ~ "land"
    ),
    logged = case_when(
      str_detect(measure, "log") ~ "log",
      T ~ "raw"
    ),
    trimming = case_when(
      str_detect(measure, "trim_first") ~ "trim_first",
      T ~ "untrimmed"
    )
  ) |>
  mutate(approach = case_when(
    type == "land" & trimming == "untrimmed" & frac == "0" ~ "generous",
    type == "land" & trimming == "untrimmed" & frac == "1" ~ "trad_land",
    type == "first_launch" & trimming == "trim_first" & frac == "1" ~ "trad_launch"
  )) |>
  filter(!is.na(approach))


test_retest_boot <- function(data, indices) {
  summ <- data |>
    slice(indices) |>
    group_by(administration_id, subject_id, pair_number, session_num) |>
    summarize(mean_var = mean(rt, na.rm = T), .groups = "drop") |>
    select(-administration_id) |>
    pivot_wider(names_from = session_num, values_from = mean_var)

  cor_test_retest <- ifelse("first_admin" %in% names(summ) & "second_admin" %in% names(summ) &
    sum(!is.na(summ$first_admin) & !is.na(summ$second_admin)) > 2,
  cor.test(summ$first_admin, summ$second_admin)$estimate, NA
  )
  return(cor_test_retest[1])
}


library(multidplyr)
library(boot)
cluster <- new_cluster(16)
cluster_library(cluster, "dplyr")
cluster_library(cluster, "stringr")
cluster_library(cluster, "purrr")
cluster_library(cluster, "tidyr")
cluster_library(cluster, "stats")
cluster_library(cluster, "tibble")
cluster_library(cluster, "boot")
cluster_copy(cluster, "test_retest_boot")
cluster_copy(cluster, "cdi_data")

rt_boot_test_retest <- pairs_long |>
  left_join(d_rt_dt_long |> ungroup() |> select(administration_id, rt, approach, window, logged, dataset_name) |>
    select(administration_id, rt, approach, window, logged, dataset_name)) |>
  group_by(approach, window, logged, dataset_name) |>
  nest() |>
  partition(cluster) |>
  mutate(corr = map(data, \(d) {
    b <- boot::boot(d, test_retest_boot, 2000)
    t <- b[["t"]][, 1]
    t_no_na <- t[!is.na(t)]
    # print(t_no_na)
    t0 <- b[["t0"]][1][1]
    # print(t0)
    if (is.na(t0)) {
      return(tibble(est = NA, lower = NA, upper = NA))
    }
    if (length(t_no_na) == 0) {
      return(tibble(est = t0, lower = NA, upper = NA))
    }
    b$R <- length(t_no_na)
    ci <- boot::boot.ci(boot.out = b, t = t_no_na, t0 = t0, type = "basic")
    return(tibble(est = t0, lower = ci$basic[4], upper = ci$basic[5]))
  })) |>
  collect() |>
  select(-data) |>
  unnest(corr)

saveRDS(rt_boot_test_retest, here("cached_intermediates", "4_rt_boot_test_retest.rds"))

```

```{r}
rt_boot_test_retest <- readRDS(here("cached_intermediates", "4_rt_boot_test_retest.rds")) |> filter(!is.na(approach)) #idk why there are nas here

library(metafor)
rt_boot_test_retest_summ <-  rt_boot_test_retest |>
  mutate(
    stdev = (upper - lower) / (1.96 * 2),
    var = stdev**2,
  ) |>
  group_by(approach, window, logged) |>
  nest() |>
  mutate(corr= map(data, \(d){
    rma(d$est, d$var) |>
      summary() |>
      coef()
  })) |> 
  unnest(corr)
  
rt_boot_test_retest |> filter(window==400) |> ggplot(aes(x=str_c(approach, "_", logged), y=est, ymin=lower, ymax=upper, color=as.character(approach)))+geom_pointrange(position = position_dodge(width=.5))+facet_wrap(~dataset_name)+coord_flip()

rt_boot_test_retest |> filter(approach=="trad_launch", logged=="raw") |> ggplot(aes(x=window, y=est, ymin=lower, ymax=upper, color=as.character(window)))+geom_pointrange()+facet_wrap(~dataset_name)+coord_flip()+scale_color_viridis(discrete=T)

rt_boot_test_retest_summ |> ggplot(aes(x=str_c(approach, "_", logged), y=estimate, ymin=ci.lb, ymax=ci.ub, color=as.character(window)))+geom_pointrange(position = position_dodge(width=.5))+coord_flip()+scale_color_viridis(discrete=T)

```


## Summary

for further purposes are doing (raw) RT on a window=400, on distractor (target) at 0 and 400, not on the other one during those 400 ms, no other requirements

```{r}
canonical_rt <- readRDS(here("cached_intermediates", "4_rt.rds")) |>
  filter(window == 400, frac == 0, time_0 == T, time_end == T) |>
  left_join(d_aoi %>%
    select(administration_id, dataset_name, subject_id, trial_id, trial_order, target_label) %>%
    distinct())

saveRDS(canonical_rt, here("cached_intermediates", "4_rt_canonical.rds"))
```

# Older


## Compare with accuracy ICC

```{r}
load(file = "cached_intermediates/3_accs.Rds")

accs_best <- accs |>
  filter(t_start == 400, t_end == 4000) |>
  filter(object == "administration") |>
  select(dataset_name, icc) |>
  mutate(type = "acc")

rts_best <- readRDS(here("cached_intermediates", "4_rt_iccs_log.rds")) |>
  filter(frac == 0, measure == "land_rt") |>
  ungroup() |>
  select(dataset_name, icc) |>
  mutate(type = "rt")

accs_best |>
  bind_rows(rts_best) |>
  ggplot(aes(x = dataset_name, y = icc, col = type)) +
  geom_point() +
  coord_flip()

accs_best |>
  bind_rows(rts_best) |>
  ggplot(aes(x = type, y = icc, col = type)) +
  geom_point() +
  stat_summary() +
  coord_flip()
```
RT tends to have higher reliability than accuracy (whether that is *meaningful* reliability is another matter) 




